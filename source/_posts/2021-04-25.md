---
title: "【译】SE-0306 Actors"
date: 2021-04-25
---

> 原文链接：[SE-0306 Actors](https://github.com/apple/swift-evolution/blob/main/proposals/0306-actors.md)

* Proposal: [SE-0306](https://github.com/apple/swift-evolution/blob/main/proposals/0306-actors.md)
* Authors: [John McCall](https://github.com/rjmccall), [Doug Gregor](https://github.com/DougGregor), [Konrad Malawski](https://github.com/ktoso), [Chris Lattner](https://github.com/lattner)
* Review Manager: [Joe Groff](https://github.com/jckarter)
* Status: **Implemented (Swift 5.5)**
* Decision Notes: [Acceptance](https://forums.swift.org/t/accepted-with-modification-se-0306-actors/47662), [First Review](https://forums.swift.org/t/se-0306-actors/45734), [Second Review](https://forums.swift.org/t/se-0306-second-review-actors/47291)
* Implementation: Partially available in [recent `main` snapshots](https://swift.org/download/#snapshots) behind the flag `-Xfrontend -enable-experimental-concurrency`

<!--
## Table of Contents

* [Introduction](#introduction)
* [Proposed solution](#proposed-solution)
   * [Actors](#actors-1)
   * [Actor isolation](#actor-isolation)
   * [Cross-actor references and Sendable types](#cross-actor-references-and-sendable-types)
   * [Closures](#closures)
   * [Actor reentrancy](#actor-reentrancy)
      * ["Interleaving" execution with reentrant actors](#interleaving-execution-with-reentrant-actors)
      * [Deadlocks with non-reentrant actors](#deadlocks-with-non-reentrant-actors)
      * [Unnecessary blocking with non-reentrant actors](#unnecessary-blocking-with-non-reentrant-actors)
      * [Existing practice](#existing-practice)
      * [Reentrancy Summary](#reentrancy-summary)
   * [Protocol conformances](#protocol-conformances)
* [Detailed design](#detailed-design)
   * [Actors](#actors-2)
   * [Actor isolation checking](#actor-isolation-checking)
      * [References and actor isolation](#references-and-actor-isolation)
      * [Protocol conformance](#protocol-conformance)
   * [Partial applications](#partial-applications)
   * [Key paths](#key-paths)
   * [inout parameters](#inout-parameters)
   * [Actor interoperability with Objective-C](#actor-interoperability-with-objective-c)
* [Source compatibility](#source-compatibility)
* [Effect on ABI stability](#effect-on-abi-stability)
* [Effect on API resilience](#effect-on-api-resilience)
* [Future Directions](#future-directions)
   * [Non-reentrancy](#non-reentrancy)
   * [Task-chain reentrancy](#task-chain-reentrancy)
* [Alternatives considered](#alternatives-considered) 
   * [Actor inheritance](#actor-inheritance)
   * [Cross-actor lets](#cross-actor-lets)
* [Revision history](#revision-history)
-->

## 简介

<!--
The Swift concurrency model intends to provide a safe programming model that statically detects [data races](https://en.wikipedia.org/wiki/Race_condition#Data_race) and other common concurrency bugs. The [Structured Concurrency][sc] proposal introduces a way to define concurrent tasks and provides data-race safety for functions and closures. This model is suitable for a number of common design patterns, including things like parallel maps and concurrent callback patterns, but is limited to working with state that is captured by closures.
-->

Swift 并发模型计划提供一个安全的编程模型，静态地检测 [data-races](https://en.wikipedia.org/wiki/Race_condition#Data_race) 和其他常见的并发错误。[结构化并发][sc]提案引入了一种定义并发任务的方法，并为函数和闭包提供了安全的 data-race。这个模型适用于许多常见的设计模式，包括像 parallel maps 和并发回调模式，但只限于处理由闭包捕获的状态。

<!--
Swift includes classes, which provide a mechanism for declaring mutable state that is shared across the program. Classes, however, are notoriously difficult to correctly use within concurrent programs, requiring error-prone manual synchronization to avoid data races. We want to provide the ability to use shared mutable state while still providing static detection of data races and other common concurrency bugs.
-->

Swift 包含了 class，它提供了一种机制来声明整个程序共享的 mutable 状态。然而，class 在并发程序中难以正确使用，需要手动同步来避免 data race，很容易出错。我们希望提供这么一种功能，在使用共享的 mutable 状态的同时，仍然提供对 data race 和其他常见并发 bug 的静态检测。

<!--
The [actor model](https://en.wikipedia.org/wiki/Actor_model) defines entities called *actors* that are perfect for this task. Actors allow you as a programmer to declare that a bag of state is held within a concurrency domain and then define multiple operations that act upon it. Each actor protects its own data through *data isolation*, ensuring that only a single thread will access that data at a given time, even when many clients are concurrently making requests of the actor. As part of the Swift Concurrency Model, actors provide the same race and memory safety properties as structured concurrency, but provide the familiar abstraction and reuse features that other explicitly declared types in Swift enjoy.
-->

[Actor 模型](https://en.wikipedia.org/wiki/Actor_model)定义了称为 *actors* 的实体，这些实体非常适合这项任务。Actor 允许你，作为一个程序员，声明一系列的状态，这些状态由一个 concurrency domain 持有，并且可以定义多个对其的操作。每个 actor 通过 *data isolation* 来保护自己的数据，确保在给定时间内只有一个线程访问它的数据，即使许多用户同时向 actor 发出请求。作为 Swift 并发模型的一部分，actor 提供了与结构化并发相同的 race 和内存安全属性，但也提供了 Swift 中其他显式声明的类型所享有的熟悉的抽象和复用的特性。

<!--more-->

Swift-evolution threads:

- [Pitch #1](https://forums.swift.org/t/concurrency-actors-actor-isolation/41613),
- [Pitch #2](https://forums.swift.org/t/pitch-2-actors/44094),
- [Pitch #3](https://forums.swift.org/t/pitch-3-actors/44470),
- [Pitch #4](https://forums.swift.org/t/pitch-4-actors/45215),
- [Pitch #5](https://forums.swift.org/t/pitch-4-actors/45215/36),
- [Pitch #6](https://forums.swift.org/t/pitch-6-actors/45519),
- [Review #1](https://forums.swift.org/t/se-0306-actors/45734)

## 解决方案

### Actors

<!--
This proposal introduces *actors* into Swift. An actor is a reference type that protects access to its mutable state, and is introduced with the keyword `actor`:
-->

这项提案将引入 *actors*。Actor 是一种引用类型，可以保护它的 mutable state 的访问，通过关键字 `actor` 引入：

```swift
actor BankAccount {
  let accountNumber: Int
  var balance: Double

  init(accountNumber: Int, initialDeposit: Double) {
    self.accountNumber = accountNumber
    self.balance = initialDeposit
  }
}
```

<!--
Like other Swift types, actors can have initializers, methods, properties, and subscripts. They can be extended and conform to protocols, be generic, and be used with generics.
-->

就像其它的 Swift 类型，`actor` 可以有构造器、方法、属性和下标。它们可以被扩展并遵循协议，可以是泛型，也可以与泛型一起使用。

<!--
The primary difference is that actors protect their state from data races. This is enforced statically by the Swift compiler through a set of limitations on the way in which actors and their instance members can be used, collectively called *actor isolation*.   
-->

最主要的区别是，actor 会保护其状态不受 data-race 影响。这一点会由 Swift 编译器静态地强制执行，通过对 actor 及其实例成员的使用方式进行一系列限制，这些限制统称为 *actor isolation*。  

### Actor 隔离

<!--
Actor isolation is how actors protect their state. For actors, the primary mechanism for this protection is by only allowing their stored instance properties to be accessed directly on `self`. For example, here is a method that attempts to transfer money from one account to another:
-->

Actor isolation 是 actor 保护其状态的方式。对于 actor 来说，这种保护的主要机制是只允许实例的存储属性通过 `self` 访问。例如，这里有一个方法，试图将钱从一个账户转到另一个账户：

```swift
extension BankAccount {
  enum BankError: Error {
    case insufficientFunds
  }
  
  func transfer(amount: Double, to other: BankAccount) throws {
    if amount > balance {
      throw BankError.insufficientFunds
    }

    balance = balance - amount
    other.balance = other.balance + amount  // error: actor-isolated property 'balance' can only be referenced on 'self'
  }
}
```

<!--
If `BankAccount` were a class, the `transfer(amount:to:)` method would be well-formed, but would be subject to data races in concurrent code without an external locking mechanism. 
-->

如果 `BankAccount` 是一个 class，`transfer(amount:to:)` 方法就是定义正确的，但在没有外部加锁的并发代码中会出现 data race。

<!--
With actors, the attempt to reference `other.balance` triggers a compiler error, because `balance` may only be referenced on `self`. The error message notes that `balance` is *actor-isolated*, meaning that it can only be accessed directly from within the specific actor it is tied to or "isolated by". In this case, it's the instance of `BankAccount` referenced by `self`. All declarations on an instance of an actor, including stored and computed instance properties (like `balance`), instance methods (like `transfer(amount:to:)`), and instance subscripts, are all actor-isolated by default. Actor-isolated declarations can freely refer to other actor-isolated declarations on the same actor instance (on `self`). Any declaration that is not actor-isolated is *non-isolated* and cannot synchronously access any actor-isolated declaration.
-->

使用 actor 时，试图访问 `other.balance` 会引发编译错误，因为 `balance` 只能通过 `self` 访问。错误信息指出 `balance` 是隔离在 actor 里的，意味着它只能从它被绑定或"隔离"的特定 actor 中直接访问。在这个例子中，它是由 `self` 引用的 `BankAccount` 的实例。所有关于 actor 实例的声明，包括存储和计算的实例属性（如 `balance`）、实例方法（如`transfer(amount:to:)`）和实例下标，默认都是被 actor 隔离的。Actor 隔离的声明可以自由地引用同一 actor 实例上的其他被 actor 隔离的声明（通过 `self`）。任何没有被 actor 隔离的的声明都是*不被隔离*的，不能同步访问任何被 actor 隔离的声明。

<!--
A reference to an actor-isolated declaration from outside that actor is called a *cross-actor reference*. Such references are permissible only when performed asynchronously. Such asynchronous accesses are turned into "messages" requesting that the actor execute the corresponding task when it can safely do so. These messages are stored in the actor's "mailbox", and the caller initiating the asynchronous function invocation may be suspended until the actor is able to process the corresponding message in its mailbox. An actor processes the messages in its mailbox sequentially, so that a given actor will never have two concurrently-executing tasks running actor-isolated code. This ensures that there are no data races on actor-isolated state, because there is no concurrency in any code that can access actor-isolated state. For example, if we wanted to make a deposit to a given bank account `account`, we could make a call to a method `deposit(amount:)` on another actor, and that call would become a message placed in the actor's mailbox and the caller would suspend. When that actor processes messages, it will eventually process the message corresponding to the deposit, executing that call within the actor's isolation domain when no other code is executing in that actor's isolation domain.
-->

从 actor 外部对一个被 actor 隔离的声明的引用被称为*跨 actor 引用*。这种引用只有在异步执行时才是允许的。这种异步访问被会转化为"消息"发送给 actor，actor 会在可以安全执行时，执行相应的任务。这些消息会被存储在 actor 的"邮箱"中，启动异步函数调用的调用者可能被暂停，直到 actor 能够处理其邮箱中的相应消息。Actor 按顺序处理其邮箱中的消息，因此，一个给定的 actor 将永远不会有两个同时执行的任务，运行被 actor 隔离的代码。这确保了被 actor 隔离的状态不会有数据竞赛，因为在任何可以访问被 actor 隔离的状态的代码都没有并发性。例如，如果我们想给一个给定的银行账户 `account` 存款，我们可以调用另一个 actor 上的方法 `deposit(amount:)`，这个调用将成为一个放在该 actor 邮箱中的消息，调用者将暂停。当该 actor 处理消息时，它最终会处理与存款相对应的消息，当没有其他代码在该 actor 的隔离域中执行时，就在该 actor 的隔离域中执行该调用。

<!--
> **Implementation note**: At an implementation level, the messages are partial tasks (described by the [Structured Concurrency][sc] proposal) for the asynchronous call, and each actor instance contains its own serial executor (also in the [Structured Concurrency][sc] proposal). The serial executor is responsible for running the partial tasks sequentially. This is conceptually similar to a serial [`DispatchQueue`](https://developer.apple.com/documentation/dispatch/dispatchqueue), but the actual implementation in the actor runtime uses a lighter-weight implementation that takes advantage of Swift's `async` functions.
-->

> **实现说明**。在实现层面上，消息是异步调用的 partial task（由[结构化并发][sc]提案描述），每个 actor 实例包含自己的 serial executor（也在[结构化并发][sc]提案中）。Serial executor 负责按顺序运行部分任务。这在概念上类似于一个串行的 [`DispatchQueue`](https://developer.apple.com/documentation/dispatch/dispatchqueue)，但在 actor 运行时的实际实现中使用了一个更轻量级的实现，利用了 Swift 的 `async` 函数。

<!--
Compile-time actor-isolation checking determines which references to actor-isolated declarations are cross-actor references, and ensures that such references use one of the two permissible mechanisms described above. This ensures that code outside of the actor does not interfere with the actor's mutable state.
-->

编译时 actor-isolation 检查会确定哪些对被 actor 隔离的声明引用是跨 actor 的引用，并确保这种引用使用上述两种允许的机制之一。这确保了 actor 之外的代码不会干扰 actor 的 mutable 状态。

<!--
Based on the above, we can implement a correct version of `transfer(amount:to:)` that is asynchronous:
-->

基于上述，我们可以实现一个正确的 `transfer(amount:to:)` 版本，它是异步的：

```swift
extension BankAccount {
  func transfer(amount: Double, to other: BankAccount) async throws {
    assert(amount > 0)

    if amount > balance {
      throw BankError.insufficientFunds
    }

    // 安全：这是当前唯一一个访问被 actor 隔离的状态的操作，并且
    // 在我们检查是否有足够的资金之后，执行到这里的逻辑之前，中间没有
    // 任何暂停点。
    balance = balance - amount
    
    // 安全：存款的操作会被放到 `other` actor 的邮箱里；
    // actor 会从邮箱里取出这个操作并且执行它，other 的
    // 账户余额将会被更新。
    await other.deposit(amount: amount)
  }
}
```

<!--
The `deposit(amount:)` operation needs to involve the state of a different actor, so it must be invoked asynchronously. This method could itself be implemented as `async`:
-->

`deposit(amount:)` 操作需要涉及不同 actor 的状态，所以必须异步调用。这个方法本身可以被实现为 `async`：

```swift
extension BankAccount {
  func deposit(amount: Double) async {
    assert(amount >= 0)
    balance = balance + amount
  }
}
```

<!--
However, this method doesn't really need to be `async`: it makes no asynchronous calls (note the lack of `await`). Therefore, it would be better defined as a synchronous function:
-->

然而，这个方法其实并不需要是 `async`：它没有进行异步调用（注意这里没有 `await`）。因此，它最好被定义为一个同步函数：

```swift
extension BankAccount {
  func deposit(amount: Double) {
    assert(amount >= 0)
    balance = balance + amount
  }
}
```

<!--
Synchronous actor functions can be called synchronously on the actor's `self`, but cross-actor references to this method require an asynchronous call. The `transfer(amount:to:)` function calls it asynchronously (on `other`), while the following function `passGo` calls it synchronously (on the implicit `self`):
-->

同步的 actor 函数可以在 actor 的 `self` 上同步调用，但是跨 actor 引用这个方法需要异步调用。`transfer(amount:to:)` 函数异步调用它（在 `other` 上），而下面的函数 `passGo` 同步调用它（在隐式 `self` 上）。

```swift
extension BankAccount {
  // Pass go and collect $200
  func passGo() {
    self.deposit(amount: 200.0)  // synchronous is okay because `self` is isolated
  }
}
```

<!--
Cross-actor references to an actor property are permitted as an asynchronous call so long as they are read-only accesses:
-->

只要是只读访问，就允许跨 actor 对 actor 属性的引用作为异步调用：

```swift
func checkBalance(account: BankAccount) {
  print(await account.balance)   // okay
  await account.balance = 1000.0 // error: cross-actor property mutations are not permitted
}
```

<!--
> **Rationale**: it is possible to support cross-actor property sets. However, cross-actor `inout` operations cannot be reasonably supported because there would be an implicit suspension point between the "get" and the "set" that could introduce what would effectively be race conditions. Moreover, setting properties asynchronously may make it easier to break invariants unintentionally if, e.g., two properties need to be updated at once to maintain an invariant.
-->

> **理由**：支持跨 actor 的属性设置是可能的。然而，不能合理地支持跨 actor 的 `inout` 操作，因为在 `get` 和 `set` 之间会有一个隐含的暂停点，可能会引入有效的竞赛条件。此外，异步设置属性可能会使其更容易无意中破坏不变性，例如，两个属性需要同时更新以保持不变性。

### 跨 actor 引用和 `Sendable` 类型

<!--
[SE-0302][se302] introduces the `Sendable` protocol. Values of types that conform to the `Sendable` protocol are safe to share across concurrently-executing code. There are various kinds of types that work well this way: value-semantic types like `Int` and `String`, value-semantic collections of such types like `[String]` or `[Int: String]`, immutable classes, classes that perform their own synchronization internally (like a concurrent hash table), and so on.
-->

[SE-0302][se302] 介绍了 `Sendable` 协议。符合 `Sendable` 协议的类型的值可以在并发执行的代码中安全地共享。有各种各样的类型以这种方式工作：像 `Int` 和 `String` 这样的值语义类型，像 `[String]` 或 `[Int: String]` 这样的值语义集合，immutable 的 class，内部执行自己同步的类（例如 ConcurrentHashMap），等等。

<!--
Actors protect their mutable state, so actor instances can be freely shared across concurrently-executing code, and the actor itself will internally maintain synchronization. Therefore, every actor type implicitly conforms to the `Sendable` protocol.
-->

Actor 会保护它的 mutable 状态，所以 actor 实例可以在并发执行的代码中自由共享，而且 actor  本身将在内部保持同步。因此，每个 actor 类型都隐式遵循 `Sendable` 协议。

<!--
All cross-actor references are, necessarily, working with values of types that are being shared across different concurrently-executed code. For example, let's say that our `BankAccount` includes a list of owners, where each owner is modeled by a `Person` class:
-->

所有的跨 actor 引用都，必须，与在并发执行的代码中共享的值一起使用。例如，假设我们的 `BankAccount` 包括一个所有者列表，每个所有者都建模为 `Person` 类：

```swift
class Person {
  var name: String
  let birthDate: Date
}

actor BankAccount {
  // ...
  var owners: [Person]

  func primaryOwner() -> Person? { return owners.first }
}
```

<!--
The `primaryOwner` function can be called asynchronously from another actor, and then the `Person` instance can be modified from anywhere:
-->

`primaryOwner` 函数可以从另一个 actor 中异步调用，然后可以从任何地方修改 `Person` 实例。

```swift
if let primary = await account.primaryOwner() {
  primary.name = "The Honorable " + primary.name  // problem: concurrent mutation of actor-isolated state
}
```

<!--
Even non-mutating access is problematic, because the person's `name` could be modified from within the actor at the same time as the original call is trying to access it. To prevent this potential for concurrent mutation of actor-isolated state, all cross-actor references can only involve types that conform to `Sendable`. For a cross-actor asynchronous call, the argument and result types must conform to `Sendable`. For a cross-actor reference to a property, the property type must conform to `Sendable`. By insisting that all cross-actor references only use `Sendable` types, we can ensure that no references to shared mutable state flow into or out of the actor's isolation domain. The compiler will produce a diagnostic for such issues. For example, the call to `account.primaryOwner()` about would produce an error like the following:
-->

即使是 non-mutating 的访问也是会有问题的，因为在原始调用试图访问这个 Person 的时候，这个 Person 的 `name` 也可能从 actor 内部被修改。为了防止这种被 actor 隔离的状态的并发 mutate 的可能性，所有的跨 actor 引用只能涉及符合 `Sendable` 的类型。对于一个跨 actor 的异步调用，参数和返回值类型必须符合 `Sendable`。对于一个跨 actor 的属性引用，属性类型必须符合 `Sendable`。通过坚持所有的跨 actor 引用只使用 `Sendable` 类型，我们可以确保对共享 mutable 状态的引用不会流入或流出 actor 的隔离域。编译器会对这类问题进行诊断。例如，对 `account.primaryOwner()` 的调用会产生类似以下的错误。

```
error: cannot call function returning non-Sendable type 'Person?' across actors
```

<!--
Note that the `primaryOwner()` function as defined above can still be used with actor-isolated code. For example, we can define a function to get the name of the primary owner, like this:
-->

请注意，上面定义的 `primaryOwner()` 函数仍然可以用于被 actor 隔离的代码。例如，我们可以定义一个函数来获取 primary owner 的名字，像这样：

```swift
extension BankAccount {
  func primaryOwnerName() -> String? {
    return primaryOwner()?.name
  }
}
```

<!--
The `primaryOwnerName()` function is safe to asynchronously call across actors because `String` (and therefore `String?`) conforms to `Sendable`.
-->

`primaryOwnerName()` 函数可以安全地跨 actor 异步调用，因为 `String`（因此也包括`String?`）符合`Sendable`。

### 闭包

<!--
The restrictions on cross-actor references only work so long as we can ensure that the code that might execute concurrently with actor-isolated code is considered to be non-isolated. For example, consider a function that schedules report generation at the end of the month:
-->

对跨 actor 引用的限制，只有在我们能确保，可能与被 actor 隔离的代码同时执行的代码，被视为不被隔离的情况下才有效。例如，一个计划生成月末报告的函数：

```swift
extension BankAccount {
  func endOfMonth(month: Int, year: Int) {
    // Schedule a task to prepare an end-of-month report.
    detach {
      let transactions = await self.transactions(month: month, year: year)
      let report = Report(accountNumber: self.accountNumber, transactions: transactions)
      await report.email(to: self.accountOwnerEmailAddress)
    }
  }
}
```

<!--
A task created with `detach` runs concurrently with all other code. If the closure passed to `detach` were to be actor-isolated, we would introduce a data race on access to the mutable state on `BankAccount`. Actors prevent this data race by specifying that a `@Sendable` closure (described in [`Sendable` and `@Sendable` closures][se302], and used in the definition of `detach` in the [Structured Concurrency][sc] proposal) is always non-isolated. Therefore, it is required to asynchronously access any actor-isolated declarations.
-->

用 `detach` 创建的任务会与所有其他代码同时运行。如果传递给 `detach` 的闭包是被 actor 隔离的，我们将在访问 `BankAccount` 的 mutable 状态时引入 data race。actor 通过指定 `@Sendable` 闭包总是不被隔离的，来防止这种数据竞赛（在 [`Sendable` 和 `@Sendable` 闭包][se302]中描述，并在[结构化并发][sc]提案中用于 `detach` 的定义）。因此，它需要异步访问任何被 actor 隔离的声明。

<!--
A closure that is not `@Sendable` cannot escape the concurrency domain in which it was formed. Therefore, such a closure will be actor-isolated if it is formed within an actor-isolated context. This is useful, for example, when applying sequence algorithms like `forEach` where the provided closure will be called serially:
-->

一个不是 `@Sendable` 的闭包不能脱离它所形成的并发域。因此，如果这样的闭包是在一个被 actor 隔离的上下文中形成的，那么它将是被 actor 隔离的。这一点很有用，例如，当应用在 `forEach` 这样的 Sequence 算法时，所提供的闭包将被连续调用：

```swift
extension BankAccount {
  func close(distributingTo accounts: [BankAccount]) async {
    let transferAmount = balance / accounts.count

    accounts.forEach { account in    // okay, closure is actor-isolated to `self`
      balance = balance - transferAmount            
      await account.deposit(amount: transferAmount)
    }
    
    await thief.deposit(amount: balance)
  }
}
```

<!--
A closure formed within an actor-isolated context is actor-isolated if it is non-`@Sendable`, and non-isolated if it is `@Sendable`. For the examples above:
-->

在一个被 actor 隔离的上下文中形成的闭包，如果它是非 `@Sendable`，则是被 actor 隔离的，如果它是 `@Sendable`，则是不被隔离的。对于上面的例子：

<!--
* The closure passed to `detach` is non-isolated because that function requires a `@Sendable` function to be passed to it.
* The closure passed to `forEach` is actor-isolated to `self` because it takes a non-`@Sendable` function.
-->

* 传递给 `detach` 的闭包是不被隔离的，因为该函数需要传递一个 `@Sendable` 闭包给它。
* 传递给 `forEach` 的闭包是与 `self` 隔离的，因为它需要一个非 `@Sendable` 函数。

### Actor 重入

<!--
Actor-isolated functions are [reentrant](https://en.wikipedia.org/wiki/Reentrancy_(computing)). When an actor-isolated function suspends, reentrancy allows other work to execute on the actor before the original actor-isolated function resumes, which we refer to as *interleaving*. Reentrancy eliminates a source of deadlocks, where two actors depend on each other, can improve overall performance by not unnecessarily blocking work on actors, and offers opportunities for better scheduling of (e.g.) higher-priority tasks. However, it means that actor-isolated state can change across an `await` when an interleaved task mutates that state, meaning that developers must be sure not to break invariants across an await. In general, this is the [reason for requiring `await`](https://github.com/apple/swift-evolution/blob/main/proposals/0296-async-await.md#suspension-points) on asynchronous calls, because various state (e.g., global state) can change when a call suspends.
-->

被 actor 隔离的函数是[可重入的](https://en.wikipedia.org/wiki/Reentrancy_(计算))。当一个被 actor 隔离的函数暂停时，可重入性允许其他工作在原本被 actor 隔离的函数恢复之前，在该 actor 上执行，我们称之为 *interleaving*（交织执行）。重入消除了一个死锁的来源，即两个 actor 相互依赖，可以通过减少 actor 非必要的阻塞，来提高整体性能，并为更好地调度（例如）优先级更高的任务提供机会。然而，这意味着当交织的任务修改状态时，被 actor 隔离的状态可能会跨 `await` 发生变化，这意味着开发者必须确保不打破跨 await 的不变性。一般来说，这是在异步调用中要求 `await` 的[原因](https://github.com/apple/swift-evolution/blob/main/proposals/0296-async-await.md#suspension-points)，因为当调用暂停时，各种状态（例如全局状态）会发生变化。

<!--
This section explores the issue of reentrancy with examples that illustrate both the benefits and problems with both reentrant and non-reentrant actors, and settles on re-entrant actors. Alternatives Considered provides potential future directions to provide more control of re-entrancy, including [non-reentrant actors](#non-reentrancy) and [task-chain reentrancy](#task-chain-reentrancy).
-->

本节会通过例子探讨重入问题，阐述重入 actor 和非重入 actor 的好处和问题，并最终确定使用重入 actor。Alternatives Considered 提供了潜在的未来方向，以提供对重入的更多控制，包括[非重入 actor](#non-reentrancy) 和[任务链重入](#task-chain-reentrancy)。

#### 可重入 actor 的交织执行

<!--
Reentrancy means that execution of asynchronous actor-isolated functions may "interleave" at suspension points, leading to increased complexity in programming with such actors, as every suspension point must be carefully inspected if the code *after* it depends on some invariants that could have changed before it suspended.
-->

重入意味着异步被 actor 隔离的函数的执行可能会在暂停点上交织，导致用这种 actor 编程的复杂度增加，因为如果暂停点**之后**的代码依赖于一些可能在暂停前发生变化的不变量，则必须仔细检查每个暂停点。

<!--
Interleaving executions still respect the actor's "single-threaded illusion", i.e., no two functions will ever execute *concurrently* on any given actor. However they may *interleave* at suspension points. In broad terms this means that reentrant actors are *thread-safe* but are not automatically protecting from the "high level" kinds of races that may still occur, potentially invalidating invariants upon which an executing asynchronous function may be relying on. To further clarify the implications of this, let us consider the following actor, which thinks of an idea and then returns it, after telling its friend about it.
-->

交织执行仍然尊重 actor 的"单线程幻觉"，也就是说，没有两个函数会在任何给定的 actor 上*并发*地执行。然而，它们可以在暂停点上*交织*。从广义上讲，这意味着可重入 actor 是*线程安全的*，但无法自动保护状态，因为"上层"的数据竞赛仍然可能发生，有可能使执行中的异步函数所依赖的不变性失效。为了进一步说明这个问题的含义，让我们看看下面这个 actor，它想到了一个想法，然后在告诉它的朋友之后将其返回：

```swift
actor Person {
  let friend: Friend
  
  // actor-isolated opinion
  var opinion: Judgment = .noIdea

  func thinkOfGoodIdea() async -> Decision {
    opinion = .goodIdea                       // <1>
    await friend.tell(opinion, heldBy: self)  // <2>
    return opinion // 🤨                      // <3>
  }

  func thinkOfBadIdea() async -> Decision {
    opinion = .badIdea                       // <4>
    await friend.tell(opinion, heldBy: self) // <5>
    return opinion // 🤨                     // <6>
  }
}
```

<!--
In the example above the `Person` can think of a good or bad idea, shares that opinion with a friend, and returns that opinion that it stored. Since the actor is reentrant this code is wrong and will return an arbitrary opinion if the actor begins to think of a few ideas at the same time.
-->

在上面的例子中，`Person` 可以想到一个好的或坏的想法，与一个朋友分享这个意见，并返回它所存储的意见。由于 actor 是可重入的，所以这段代码是错误的，如果 actor 同时开始思考几个想法，就会返回一个任意的意见：

<!--
This is exemplified by the following piece of code, exercising the `decisionMaker` actor:
-->

以下是典型的 `decisionMaker` actor 调用代码，可以说明这一点：

```swift
let goodThink = detach { await person.thinkOfGoodIdea() }  // runs async
let badThink = detach { await person.thinkOfBadIdea() } // runs async

let shouldBeGood = await goodThink.get()
let shouldBeBad = await badThink.get()

await shouldBeGood // could be .goodIdea or .badIdea ☠️
await shouldBeBad
```

<!--
This snippet _may_ result (depending on timing of the resumptions) in the following execution:
-->

这个片段 _可能_ 会产生（取决于恢复的时间）以下的执行顺序：

```swift
opinion = .goodIdea                // <1>
// 暂停: await friend.tell(...) // <2>
opinion = .badIdea                 // | <4> (!)
// 暂停: await friend.tell(...) // | <5>
// 恢复: await friend.tell(...)  // <2>
return opinion                     // <3>
// 恢复: await friend.tell(...)  // <5>
return opinion                     // <6>
```

<!--
But it _may_ also result in the "naively expected" execution, i.e. without interleaving, meaning that the issue will only show up intermittently, like many race conditions in concurrent code.
-->

但它也 _可能_ 导致 "naively expected" 的执行，即没有交织，这意味着问题只会间歇性地出现，就像并发代码中的许多竞赛条件。

<!--
The potential for interleaved execution at suspension points is the primary reason for the requirement that every suspension point be [marked by `await`](https://github.com/apple/swift-evolution/blob/main/proposals/0296-async-await.md#suspension-points) in the source code, even though `await` itself has no semantic effect. It is an indicator that any shared state might change across the `await`, so one should avoid breaking invariants across an `await`, or otherwise depending on the state "before" to be identical to the state "after".
-->

在暂停点上有可能出现交织执行，这是要求每个暂停点在源代码中[用 `await` 标记](https://github.com/apple/swift-evolution/blob/main/proposals/0296-async-await.md#suspension-points)的主要原因，尽管 `await` 本身没有语义作用。这是一个提示，表明任何共享状态都可能在 `await` 中发生变化，所以应该避免在 `await` 中破坏不变性，或者依赖 "之前"的状态与"之后"的状态一致。

<!--
Generally speaking, the easiest way to avoid breaking invariants across an `await` is to encapsulate state updates in synchronous actor functions. Effectively, synchronous code in an actor provides a [critical section](https://en.wikipedia.org/wiki/Critical_section), whereas an `await` interrupts a critical section. For our example above, we could effect this change by separating "opinion formation" from "telling a friend your opinion". Indeed, telling your friend your opinion might reasonably cause you to change your opinion!
-->

一般来说，避免跨 `await` 破坏不变性的最简单方法是将状态更新封装在同步 actor 函数中。实际上，actor 中的同步代码提供了一个[临界区](https://en.wikipedia.org/wiki/Critical_section)，而 `await` 中断了一个临界区。对于我们上面的例子，我们可以通过将 "optinion fomration" 与 "telling a friend your opinion" 分开来实现这个修改。事实上，告诉你的朋友你的观点可能会合理地导致你改变你的观点！

#### 不可重入的 actor 的死锁

<!--
The opposite of reentrant actor functions are "non-reentrant" functions and actors. This means that while an actor is processing an incoming actor function call (message), it will *not* process any other message from its mailbox until it has completed running this initial function. Essentially, the entire actor is blocked from executing until that task completes.
-->

与可重入的 actor 函数相反的是"不可重入"的函数和 actor。这意味着当一个actor 正在处理一个传入的 actor 函数调用（消息）时，它将*不会*处理来自其邮箱的任何其他消息，直到它完成运行这个初始函数。本质上，整个 actor 都会被阻塞，直到该任务完成。

<!--
If we take the example from the previous section and use a non-reentrant actor, it will execute correctly, because no work can be scheduled on the actor until `friend.tell` has completed:
-->

如果我们以上一节的例子为例，使用一个非重入 actor，它将正确执行，因为在 `friend.tell` 完成之前，不能给 actor 安排工作：

```swift
// assume non-reentrant
actor DecisionMaker {
  let friend: DecisionMaker
  var opinion: Judgment = .noIdea

  func thinkOfGoodIdea() async -> Decision {
    opinion = .goodIdea                                   
    await friend.tell(opinion, heldBy: self)
    return opinion // ✅ always .goodIdea
  }

  func thinkOfBadIdea() async -> Decision {
    opinion = .badIdea
    await friend.tell(opinion, heldBy: self)
    return opinion // ✅ always .badIdea
  }
}
```

<!--
However, non-entrancy can result in deadlock if a task involves calling back into the actor. For example, let's stretch this example further and have our friend try to convince us to change a bad idea:
-->

然而，如果一个任务涉及到回调 actor，非重入就会导致死锁。例如，让我们进一步延伸这个例子，让我们的朋友试图说服我们改变一个坏主意：

```swift
extension DecisionMaker {
  func tell(_ opinion: Judgment, heldBy friend: DecisionMaker) async {
    if opinion == .badIdea {
      await friend.convinceOtherwise(opinion)
    }
  }
}
```

<!--
With non-reentrant actors, `thinkOfGoodIdea()` will succeed under this implementation, because `tell` essentially does nothing. However, `thinkOfBadIdea()` will deadlock because the original decision maker (call it `A`) is locked when it calls `tell` on another decision maker (call it `B`). `B` then tries to convince `A` otherwise, but that call cannot execute because `A` is already locked. Hence, the actor itself deadlocks and cannot progress.
-->

对于非重入的 actor，`thinkOfGoodIdea()` 在这种实现下会成功，因为 `tell` 基本上什么都不做。然而，`thinkOfBadIdea()` 将陷入僵局，因为原来的决策者（称为 A）在对另一个决策者（称为 B）调用 `tell` 时被锁定。然后，`B` 试图说服 `A`，但该调用无法执行，因为 `A` 已经被锁定。因此，actor 自身进入死锁，无法进行下去。

<!--
> The term "deadlock" used in these discussions refer to actors asynchronously waiting on "each other," or on "future work of self". No thread blocking is necessary to manifest this issue.
-->

> 这些讨论中使用的术语"死锁"是指 actor 异步地等待"彼此"或"自己的未来工作"。对于这个问题来说，线程阻塞不是必要条件。

<!--
In theory, a fully non-reentrant model would also deadlock when calling asynchronous functions on `self`. However, since such calls are statically determinable to be on `self`, they would execute immediately and therefore not block.
-->

理论上，一个完全不重入的模型在调用 `self` 上的异步函数时也会出现死锁。然而，由于这种调用可以静态地确定是在 `self` 上，它们会立即执行，因此不会阻塞。

<!--
Deadlocks with non-reentrant actors could be detected with runtime tools that detect cyclic call graphs once they've occurred, much like tools exist to find reference cycles in data structures at runtime. However, such deadlocks cannot generally be identified statically (e.g., with the compiler or static analysis), because call graphs require whole-program knowledge and can change dynamically depending on the data provided to the program.
-->

可以用运行时工具来检测非重入 actor 的死锁，这些工具可以在死锁发生后检测循环调用图，就像在运行时检测数据结构中的引用循环一样。然而，这种死锁通常不能被静态地识别（例如，用编译器或静态分析），因为调用图需要整个程序的知识，并且会根据提供给程序的数据动态变化。

<!--
Deadlocked actors would be sitting around as inactive zombies forever. Some runtimes solve deadlocks like this by making every single actor call have a timeout (such timeouts are already useful for distributed actor systems). This would mean that each `await` could potentially `throw`, and that either timeouts or deadlock detection would have to always be enabled. We feel this would be prohibitively expensive, because we envision actors being used in the vast majority of concurrent Swift applications. It would also muddy the waters with respect to cancellation, which is intentionally designed to be explicit and cooperative. Therefore, we feel that the approach of automatically cancelling on deadlocks does not fit well with the direction of Swift Concurrency.
-->

死锁的 actor 将永远作为不活跃的僵尸呆在那里。一些运行时为了解决这样的死锁问题，让每个 actor 的调用都有一个超时时间（分布式 actor 系统已经证实这种超时机制确实行之有效）。这意味着每个 `await` 都有可能 `throw`，而超时或死锁检测都必须始终被启用。我们认为这个代价太过昂贵，因为我们设想在绝大多数并发的 Swift 应用中都会使用 actor。这也会搅浑取消机制，取消机制是有意设计成明确和可合作的。因此，我们觉得自动取消死锁的方法并不符合 Swift 并发的方向。

#### 不可重入的 actor 非必要的阻塞

<!--
Consider an actor that handles the download of various images and maintains a cache of what it has downloaded to make subsequent accesses faster:
-->

想想看一个处理各种图片下载的 actor，并保存对已下载内容的缓存，以使后续访问更快：

```swift
// assume non-reentrant
actor ImageDownloader { 
  var cache: [URL: Image] = [:]

  func getImage(_ url: URL) async -> Image {
    if let cachedImage = cache[url] {
      return cachedImage
    }
    
    let data = await download(url)
    let image = await Image(decoding: data)
    return cache[url, default: image]
  }
}
```

<!--
This actor is functionally correct, whether it is re-entrant or not. However, if it is non-reentrant, it will completely serialize the download of images: once a single client asked for an image, all other clients are blocked from starting any requests--even ones that would hit the cache or which ask for images at different URLs---until that first client has had its image fully downloaded and decoded.
-->

这个 actor 在功能上是正确的，不管它是否是可重入的。然而，如果它是非重入的，它将逐个执行图片的下载：一旦一个客户端请求了一张图片，所有其他的客户端将被阻止开始任何请求 -- 即使是那些会击中缓存或在不同的 URL 上请求图片的请求 -- 直到第一个客户端将其图片完全下载和解码。

<!--
With a reentrant actor, multiple clients can fetch images independently, so that (say) they can all be at different stages of downloading and decoding an image. The serialized execution of partial tasks on the actor ensures that the cache itself can never get corrupted. At worst, two clients might ask for the same image URL at the same time, in which there will be some redundant work. 
-->

而使用可重入的 actor 时，多个客户端可以独立地获取图像，这样（比如）他们都可以处于下载和解码图像的不同阶段。actor 上部分任务的串行执行确保了缓存本身不会被破坏。在最坏的情况下，两个客户可能会同时要求获得相同的图像URL，其中会有一些多余的工作。

#### 已有的实践

<!--
There are a number of existing actor implementations that have considered the notion of reentrancy:
-->

有一些现有的 actor 实现已经考虑了重入的概念：

<!--
* Erlang/Elixir ([gen_server](https://medium.com/@eduardbme/erlang-gen-server-never-call-your-public-interface-functions-internally-c17c8f28a1ee)) showcases a simple "loop/deadlock" scenario and how to detect and fix it,
* Akka ([Persistence persist/persistAsync](https://doc.akka.io/docs/akka/current/persistence.html#relaxed-local-consistency-requirements-and-high-throughput-use-cases) is effectively _non-reentrant behavior by default_, and specific APIs are designed to allow programmers to _opt into_ reentrant whenever it would be needed. In the linked documentation `persistAsync` is the re-entrant version of the API, and it is used _very rarely_ in practice. Akka persistence and this API has been used to implement bank transactions and process managers, by relying on the non-reentrancy of `persist()` as a killer feature, making implementations simple to understand and _safe_. Note that Akka is built on top of Scala, which does not provide `async`/`await`. This means that mailbox-processing methods are more synchronous in nature, and rather than block the actor while waiting for a response, they would handle the response as a separate message receipt.
* Orleans ([grains](https://dotnet.github.io/orleans/docs/grains/reentrancy.html)) are also non-reentrant by default, but offer extensive configuration around reentrancy. Grains and specific methods can be marked as being re-entrant, and there is even a dynamic mechanism by which one can implement a run-time predicate to determine whether an invocation can interleave. Orleans is perhaps closest to the Swift approach described here, because it is built on top of a language that provides `async`/`await` (C#). Note that Orleans *had* a feature called [call-chain reentrancy](https://dotnet.github.io/orleans/docs/grains/reentrancy.html#reentrancy-within-a-call-chain), which we feel is a promising potential direction: we cover it later in this proposal in our section on [task-chain reentrancy](#task-chain-reentrancy).
-->

* Erlang/Elixir（[gen_server](https://medium.com/@eduardbme/erlang-gen-server-never-call-your-public-interface-function-internally-c17c8f28a1ee)）展示了一个简单的 "loop/deadlock" 场景以及如何检测和修复它。
* Akka（[Persistence persist/persistAsync](https://doc.akka.io/docs/akka/current/persistence.html#relaxed-local-consistency-requirements-and-high-throughput-use-cases))实际上是默认 _非重入的_ ，特定的 API 被设计为允许程序员在需要时 _选择_ 重入。在链接的文档中，`persistAsync` 是 API 的可重入版本，它在实践中很少被使用。Akka 持久化和这个 API 已经被用来实现银行交易和流程管理，依靠 `persist()` 的非重入性作为杀手锏，使得实现简单易懂且 _安全_ 。注意，Akka 是建立在 Scala 之上的，Scala 不提供 `async`/`await`。这意味着邮箱处理方法在本质上更具有同步性，与其在等待响应时阻塞 actor，不如将响应作为一个单独的消息接收来处理。
* Orleans（[grains](https://dotnet.github.io/orleans/docs/grains/reentrancy.html)）默认也是非重入的，但围绕重入性提供了可拓展的配置。Grains 和特定的方法可以被标记为可重入，甚至还有一种动态机制，可以实现一个运行时的断言来确定一个调用是否可以交织执行。Orleans 也许最接近这里描述的 Swift 方法，因为它是建立在提供 `async`/`await` 的语言之上的（C#）。请注意，Orleans *有*一个叫做[调用链重入](https://dotnet.github.io/orleans/docs/grains/reentrancy.html#reentrancy-within-a-call-chain)的功能，我们认为这是一个很有前途的潜在方向：我们在本提案后面的[任务链重入](#task-chain-reentrancy)一节中会介绍它。

#### Reentrancy 总结

<!--
This proposal provides only reentrant actors. However, the [Future Directions](#future-directions) section describes potential future design directions that could add opt-in non-reentrancy.
-->

本提案只提供了可重入的 actor。然而，[未来方向](#future-directions)小节里阐述了潜在的未来设计方向，可以增加可选的非重入性。

<!--
> **Rationale**: Reentrancy by default all but eliminates the potential for deadlocks. Moreover, it helps ensure that actors can make timely progress within a concurrent system, and that a particular actor does not end up unnecessarily blocked on a long-running asynchronous operation (say, downloading a file). The mechanisms for ensuring safe interleaving, such as using synchronous code when performing mutations and being careful not to break invariants across `await` calls, are already present in the proposal.
-->

> **理由**。默认情况下，重入可以消除死锁的可能性。此外，它还有助于确保 actor 在并发系统中能及时取得进展，并确保特定的 actor 不会在长期运行的异步操作（例如，下载文件）中出现不必要的阻塞。确保安全交织的机制，例如在执行突变时使用同步代码，并注意不破坏跨 `await` 调用的不变性，已经存在于该提案中。

### Protocol conformances

<!--
All actor types implicitly conform to a new protocol, `Actor`:
-->

所有的 actor 类型都默认遵循一个新的协议，`Actor`。

```swift
protocol Actor : AnyObject, Sendable { }
```

<!--
> **Note**: The definition of the `Actor` protocol is intentionally left blank. The [custom executors proposal][customexecs] will introduce requirements into the `Actor` protocol. These requirements will be implicitly synthesized by the implementation when not explicitly provided, but can be explicitly provided to allow actors to control their own serialized execution.
-->

> **注意**。`Actor` 协议的定义是故意留白的。[Custom executor 提案][customexecs]将在 `Actor` 协议中引入实现要求。当没有明确提供时，这些要求将被实现隐含地合成，但可以明确地提供，以允许 actor 控制自己的串行执行。

<!--
The `Actor` protocol can be used to write generic operations that work across all actors, including extending all actor types with new operations. As with actor types, instance properties, functions, and subscripts defined on the `Actor` protocol (including extensions thereof) are actor-isolated to the `self` actor. For example, 
-->

`Actor` 协议可以用来编写适用于所有 actor 的通用操作，包括用新的操作扩展所有 actor 类型。与 actor 类型一样，在 `Actor` 协议上定义的实例属性、函数和下标（包括其扩展）是与 `self` actor 隔离的。例如：

```swift
protocol DataProcessible: Actor {  // only actor types can conform to this protocol
  var data: Data { get }           // actor-isolated to self
}

extension DataProcessible {
  func compressData() -> Data {    // actor-isolated to self
    // use data synchronously
  }
}

actor MyProcessor : DataProcessible {
  var data: Data                   // okay, actor-isolated to self
  
  func doSomething() {
    let newData = compressData()   // okay, calling actor-isolated method on self
    // use new data
  }
}

func doProcessing<T: DataProcessible>(processor: T) async {
  await processor.compressData() // not actor-isolated, so we must interact asynchronously with the actor
}
```

<!--
No other kind of concrete type (class, enum, struct, etc.) can conform to the `Actor` protocol, because they cannot define actor-isolated operations.
-->

其他类型的具体类型（类、枚举、结构等）都不能遵循 `Actor` 协议，因为它们不能定义被 actor 隔离的操作。

<!--
Actors can also conform to protocols with `async` requirements, because all clients will already have to interact with those requirements asynchronously, giving the actor the ability to protect its isolated state. For example:
-->

Actor 也可以遵循具有 `async` 要求的协议，因为所有的客户都已经不得不与这些实现要求进行异步交互，使得 actor 有能力保护它隔离的状态。比如说：

```swift
protocol Server {
  func send<Message: MessageType>(message: Message) async throws -> Message.Reply
}

actor MyActor: Server {
  func send<Message: MessageType>(message: Message) async throws -> Message.Reply { // okay: this method is actor-isolated to 'self', satisfies asynchronous requirement
  }
}
```

<!--
Actors cannot otherwise be made to conform to non-`Actor` protocols with synchronous requirements. However, there is a separate proposal on [controlling actor isolation][isolationcontrol] that allows such conformances when they can implemented in a manner that does not reference any mutable actor state.
-->

Actor 不能被用来遵循具有同步要求的非 `Actor` 协议。然而，有一个关于[控制 actor 隔离][isolationcontrol]的单独提议，当它们能够以不引用任何 mutable actor 状态的方式实现时，允许这种遵循。

## 具体设计

### Actors

<!--
An actor type can be declared with the `actor` keyword:
-->

Actor 类型可以用 `actor` 关键字来声明：

```swift
/// Declares a new type BankAccount
actor BankAccount {
  // ...
}
```

<!--
Each instance of the actor represents a unique actor. The term "actor" can be used to refer to either an instance or the type; where necessary, one can refer to the "actor instance" or "actor type" to disambiguate.
-->

每个 actor 的实例都代表一个唯一的 actor。术语 "actor" 可以用来指代实例或类型；在必要时，人们可以使用 ”actor 实例" 或 "actor 类型 "来消除歧义。

<!--
Actors are similar to other concrete nominal types in Swift (enums, structs, and classes). Actor types can have `static` and instance methods, properties, and subscripts. They have stored properties and initializers like structs and classes. They are reference types like classes, but do not support inheritance, and therefore do not have (or need) features such as `required` and `convenience` initializers, overriding, or `class` members, `open` and `final`. Where actor types differ in behavior from other types is primarily driven by the rules of actor isolation, described below.
-->

Actor 类似于 Swift 中的其他具体名义类型（enum, struct 和 class）。Actor 类型可以有 `static` 和实例方法、属性和下标。它们像 stuct 和 class 一样有存储属性和初始化器。它们像 class 一样是引用类型，但不支持继承，因此没有（或不需要）诸如 `required` 和 `convenience` 初始化器、override 、或 `class` 成员、`open` 和 `final` 等功能。Actor 类型在行为上与其他类型的不同之处主要是由 actor isolation 的规则驱动的，如下所述。

<!--
By default, the instance methods, properties, and subscripts of an actor have an isolated `self` parameter. This is true even for methods added retroactively on an actor via an extension, like any other Swift type. Static methods, properties, and subscripts do not have a `self` parameter that is an instance of the actor, so they are not actor-isolated.
-->

默认情况下，actor 的实例方法、属性和下标有一个隔离的 `self` 参数。即使是通过扩展在 actor 上追加的方法也是如此，就像其他 Swift 类型一样。静态方法、属性和下标没有一个作为 actor 实例的 `self` 参数，所以它们不是与被 actor 隔离的。

```swift
extension BankAccount {
  func acceptTransfer(amount: Double) async { // actor-isolated
    balance += amount
  }
}  
```

### Actor 隔离检查

<!--
Any given declaration in a program is either actor-isolated or is non-isolated. A function (including accessors) is actor-isolated if it is defined on an actor type (including protocols where `Self` conforms to `Actor`, and extensions thereof). A mutable instance property or instance subscript is actor-isolated if it is defined on an actor type. Declarations that are not actor-isolated are called non-isolated.
-->

程序中的任何给定的声明要么是被 actor 隔离的，要么是不被隔离的。如果一个函数（包括访问器）定义在一个 actor 类型上（包括 `Self` 符合 `Actor` 的协议，以及其扩展），那么它就是被 actor 隔离的。如果一个 mutable 的实例属性或实例下标是定义在一个 actor 类型上的，那么它就是被 actor 隔离的。不被 actor 隔离的声明被称为不被隔离的（non-isolated）。

<!--
The actor isolation rules are checked in a number of places, where two different declarations need to be compared to determine if their usage together maintains actor isolation. There are several such places:
-->

Actor isolation 规则会在很多地方被检查，在这些地方，需要对两个不同的声明进行比较，以确定它们在一起的使用是否保持了 actor 的隔离。有几个这样的地方：

<!--
* When the definition of one declaration (e.g., the body of a function) references another declaration, e.g., calling a function, accessing a property, or evaluating a subscript.
* When one declaration satisfies a protocol requirement.
-->

* 当一个声明的定义（例如，一个函数的主体）引用另一个声明时，例如，调用一个函数，访问一个属性，或执行一个下标。
* 当一个声明满足了一个协议要求时。

<!--
We'll describe each scenario in detail.
-->

我们将详细地描述每种情况。

#### 引用和 actor 的隔离

<!--
An actor-isolated non-`async` declaration can only be synchronously accessed from another declaration that is isolated to the same actor. For synchronous access to an actor-isolated function, the function must be called from another actor-isolated function. For synchronous access to an actor-isolated instance property or instance subscript, the instance itself must be actor-isolated.
-->

一个被 actor 隔离的非 `async` 声明只能从另一个与同一 actor 隔离的声明中被同步访问。对于同步访问一个被 actor 隔离的函数，该函数必须从另一个被 actor 隔离的函数中调用。对于同步访问一个被 actor 隔离的实例属性或实例下标，该实例本身必须是被 actor 隔离的。

<!--
An actor-isolated declaration can be asynchronously accessed from any declaration, whether it is isolated to another actor or is non-isolated. Such accesses are asynchronous operations, and therefore must be annotated with `await`. Semantically, the progam will switch to the actor to perform the synchronous operation, and then switch back to the caller's executor afterward.
-->

一个被 actor 隔离的声明可以从任何声明中被异步访问，无论它是被隔离到另一个 actor 还是不被隔离。这样的访问是异步操作，因此必须用` await` 来注释。从语义上讲，程序将切换 actor 来执行同步操作，之后再切换回调用者的 executor。

<!--
For example:
-->

例如：

```swift
actor MyActor {
  let name: String
  var counter: Int = 0
  func f()
}

extension MyActor {
  func g(other: MyActor) async {
    print(name)                // okay, name is isolated to "self"
    print(other.name)          // error: name is isolated to "self", not "other"
    print(await other.name)    // okay, asynchronous access
    print(counter)             // okay, g() is isolated to "self"
    print(other.counter)       // error: g() is isolated to "self", not "other"
    print(await other.counter) // okay, asynchronous access
    f()                        // okay, f() is isolated to "self"
    await other.f()            // okay, other is not isolated to "self" but asynchronous access is permitted
  }
}
```

#### Protocol conformance

<!--
When a given declaration (the "witness") satisfies a protocol requirement (the "requirement"), the protocol requirement can be satisfied by the witness if:
-->

当某项声明（"witness"）满足某项协议要求（"requirement"）时，在以下情况下，witness 可以满足该协议要求：

<!--
* The requirement is `async`, or
* the requirement and witness are both actor-isolated.
-->

* Requirement 是 `async`，或
* Requirement 和 witness 都是被 actor 隔离的。

<!--
An actor can satisfy an asynchronous requirement because any uses of the requirement are asynchronous, and can therefore suspend until the actor is available to execute them. Note that an actor can satisfy an asynchronous requirement with a synchronous one, in which case the normal notion of asynchronously accessing a synchronous declaration on an actor applies. For example:
-->

一个 actor 可以满足异步的要求，因为对该要求的任何使用都是异步的，因此可以暂停，直到该 actor 可以执行它们。请注意，一个 actor 可以用一个同步的实现来满足一个异步的实现需求，在这种情况下，异步访问一个 actor 上的同步声明的正常规则是适用的。比如说：

```swift
protocol Server {
  func send<Message: MessageType>(message: Message) async throws -> Message.Reply
}

actor MyServer : Server {
  func send<Message: MessageType>(message: Message) throws -> Message.Reply { ... }  // okay, asynchronously accessed from clients of the protocol
}
```

### Partial applications

<!--
Partial applications of isolated functions are only permitted when the expression is a direct argument whose corresponding parameter is non-escaping and non-Sendable. For example:
-->

只有当表达式是一个直接的参数，其对应的参数是 non-escaping 和 non-Sendable 时，才允许隔离函数的 partial applications。例如：

```swift
func runLater<T>(_ operation: @escaping () -> T) -> T { ... }

actor A {
  func f(_: Int) -> Double { ... }
  func g() -> Double { ... }
  
  func useAF(array: [Int]) {
    array.map(self.f)                     // okay
    detach(operation: self.g)             // error: self.g has non-sendable type () -> Double that cannot be converted to a @Sendable function type
    runLater(self.g)                      // error: self.g has escaping function type () -> Double
  }
}
```

<!--
These restrictions follow from the actor isolation rules for the "desugaring" of partial applications to closures. The two erroneous cases above fall out from the fact that the closure would be non-isolated in a closure that performs the call, so access to the actor-isolated function `g` would have to be asynchronous. Here are the "desugared" forms of the partial applications:
-->

这些限制来自于 actor 对闭包的 partial applications "desugaring" 后生效的隔离规则。上面两个错误的例子是由于在执行调用的闭包中，闭包将是不被隔离的，所以对被 actor 隔离的函数 `g` 的访问必须是异步的。下面是 partial application 的 "desugared" 形式：

```swift
extension A {
  func useAFDesugared(a: A, array: [Int]) {
    array.map { f($0) } )      // okay
    detach { g() }             // error: self is non-isolated, so call to `g` cannot be synchronous
    runLater { g() }           // error: self is non-isolated, so the call to `g` cannot be synchronous
  }
}
```

### Key paths

<!--
A key path cannot involve a reference to an actor-isolated declaration:
-->

一个 keypath 不能涉及对被 actor 隔离声明的引用：

```swift
actor A {
  var storage: Int
}

let kp = \A.storage  // error: key path would permit access to actor-isolated storage
```

<!--
> **Rationale**: Allowing the formation of a key path that references an actor-isolated property or subscript would permit accesses to the actor's protected state from outside of the actor isolation domain. As an alternative to this rule, we could remove the `Sendable` conformance from key paths, such that one could form key paths to actor-isolated state but they could not be shared.
--> 

> **理由**。允许生成引用 actor isolation 的属性或下标的 keypath，将允许从 actor isolation 域之外访问 actor 的受保护状态。作为这一规则的替代方案，我们可以从 keypath 中移除 `Sendable` 的遵循，这样人们就可以形成指向被 actor 隔离状态的 keypath，但它们不能被共享。

### inout 参数

<!--
Actor-isolated stored properties can be passed into synchronous functions via `inout` parameters, but it is ill-formed to pass them to asynchronous functions via `inout` parameters. For example:
-->

被 actor 隔离的存储属性可以通过 `inout` 参数传递到同步函数中，但通过 `inout` 参数传递到异步函数中是不符合规定的。比如说：

```swift
func modifiesSynchronously(_: inout Double) { }
func modifiesAsynchronously(_: inout Double) async { }

extension BankAccount {
  func wildcardBalance() async {
    modifiesSynchronously(&balance)        // okay
    await modifiesAsynchronously(&balance) // error: actor-isolated property 'balance' cannot be passed 'inout' to an asynchronous function
  }
}  

class C { var state : Double }
struct Pair { var a, b : Double }
actor A {
  let someC : C
  var somePair : Pair

  func inoutModifications() async {
    modifiesSynchronously(&someC.state)        // okay
    await modifiesAsynchronously(&someC.state) // not okay
    modifiesSynchronously(&somePair.a)         // okay
    await modifiesAsynchronously(&somePair.a)  // not okay
  }
}
```

<!--
> **Rationale**: this restriction prevents exclusivity violations where the modification of the actor-isolated `balance` is initiated by passing it as `inout` to a call that is then suspended, and another task executed on the same actor then attempts to access `balance`. Such an access would then result in an exclusivity violation that will terminate the program. While the `inout` restriction is not required for memory safety (because errors will be detected at runtime), the default re-entrancy of actors makes it very easy to introduce non-deterministic exclusivity violations. Therefore, we introduce this restriction to eliminate that class of problems that where a race would trigger an exclusivity violation.
-->

> **理由**：这个限制可以防止违反独占性，在这种情况下，对被 actor 隔离的 `balance` 的修改是通过把它作为 `inout` 传递给一个调用而开始的，这个调用被暂停，然后在同一个 actor 上执行的另一个任务试图访问 `balance`。这样的访问将导致违反独占性，从而终止程序。虽然 `inout` 的限制对于内存安全来说是不需要的（因为错误会在运行时被检测到），但 actor 的默认重入性使得它很容易引入非确定性的独占性违规。因此，我们引入了这个限制，以消除这类问题，即竞赛会触发独占性的违规。

### Actor 与 Objective-C 的交互

<!--
An actor type can be declared `@objc`, which implicitly provides conformance to `NSObjectProtocol`:
-->

一个 actor 类型可以被声明为 `@objc`，它隐式地提供了对 `NSObjectProtocol` 的遵循：

```swift
@objc actor MyActor { ... }
```

<!--
A member of an actor can only be `@objc` if it is either `async` or is not isolated to the actor. Synchronous code that is within the actor's isolation domain can only be invoked on `self` (in Swift). Objective-C does not have knowledge of actor isolation, so these members are not permitted to be exposed to Objective-C. For example:
-->

Actor 的成员只有在 `async` 或不被 actor 隔离的情况下才能标注为 `@objc`。在 actor 的隔离域内的同步代码只能在 `self` 上调用（在 Swift 中）。Objective-C 并不了解 actor 的隔离，所以这些成员不允许暴露在 Objective-C 中。比如说：

```swift
@objc actor MyActor {
    @objc func synchronous() { } // error: part of actor's isolation domain
    @objc func asynchronous() async { } // okay: asynchronous, exposed to Objective-C as a method that accepts a completion handler
    @objc nonisolated func notIsolated() { } // okay: non-isolated
}
```

## 代码兼容性

<!--
This proposal is mostly additive, and should not break source compatibility. The `actor` contextual keyword to introduce actors is a parser change that does not break existing code, and the other changes are carefully staged so they do not change existing code. Only new code that introduces actors or actor-isolation attributes will be affected.
-->

这个建议主要是补充性的，不应该会破坏源代码的兼容性。引入 Actor 的 `actor` 上下文关键字是对解析器的改变，不会破坏现有的代码，其他的改变也是精心设计的，所以它们不会改变现有的代码。只有引入 actors 或 actor-isolation 属性的新代码会受到影响。

## 对于 ABI 稳定性的影响

<!--
This is purely additive to the ABI. Actor isolation itself is a static notion that is not part of the ABI.
-->

这纯粹是对 ABI 的补充。Actor isolation 本身是一个静态概念，不是 ABI 的一部分。

## 对于 API 稳定性的影响

<!--
Nearly all changes in actor isolation are breaking changes, because the actor isolation rules require consistency between a declaration and its users:
-->

几乎所有 actor isolation 的改变都是破坏性的改变，因为 actor isolation 规则要求声明和其用户之间的一致性。

<!--
* A class cannot be turned into an actor or vice versa.
* The actor isolation of a public declaration cannot be changed.
-->

* 一个 class 不能变成一个 actor，反之亦然。
* 一个公共声明的 actor isolation 不能被改变。

## 未来方向

### Non-reentrancy

<!--
We could introduce a `@reentrant` attribute may be added to any actor-isolated function, actor, or extension of an actor to describe how it is reentrant. The attribute would have several forms:
-->

我们可以引入一个 `@reentrant` 注解，它可以被添加到任何被 actor 隔离的函数、actor 或 actor 的扩展中，以描述它是如何重入的。该属性将有几种形式：

<!--
* `@reentrant`: Indicates that each potential suspension point within the function bodies covered by the attribute is reentrant.
* `@reentrant(never)`: Indicates that each potential suspension point within the function bodies covered by the attribute is non-reentrant.
-->

* `@reentrant`: 表示被注解的函数体中的每个潜在暂停点是可重入的。
* `@reentrant(never)`: 表示被注解的函数体中的每个潜在暂停点都是不可重入的。

<!--
A non-reentrant potential suspension point prevents any other asynchronous call from executing on the actor until it has completed. Note that asynchronous calls to non-reentrant async functions directly on `self` are exempted from this check, so an actor can asynchronously call itself without producing a deadlock.
-->

一个不可重入的潜在暂停点会阻止任何其他异步调用在 actor 上执行，直到它完成。请注意，直接在 `self` 上对非重进异步函数的异步调用不受这个检查的影响，所以一个 actor 可以异步调用自己而不产生死锁。

<!--
> **Rationale**: Allowing direct calls on `self` eliminates an obvious set of deadlocks, and requires only the same static knowledge as actor-isolation checking for synchronous access to actor-isolated state.
-->

> **理由**。允许直接调用 `self` 可以消除一系列明显的死锁，并且只需要与被 actor 隔离检查相同的静态信息，就可以同步访问被 actor 隔离的状态。

<!--
It is an error to have a `@reentrant` attribute on a non-isolated function, non-actor type, or extension of a non-actor type. Only one `@reentrant` attribute may occur on a given declaration. The reentrancy of an actor-isolated non-type declaration is determined by finding a suitable `@reentrant` attribute. The search is as follows:
-->

在一个不被隔离的函数、非 actor 类型或非 actor 类型的扩展上使用 `@reentrant` 注解是错误的。只有给定的声明中可以使用 `@reentrant` 注解。一个被 actor 隔离的非类型声明的可重入性是通过寻找一个合适的 `@reentrant` 属性来确定的。搜索的路径如下：

<!--
1. The declaration itself.
2. If the declaration is a non-type member of an extension, the extension.
3. If the declaration is a non-type member of a type (or extension thereof), the type definition.
-->

1. 声明本身。
2. 如果声明是一个扩展的非类型成员，则是该扩展。
3. 如果声明是一个类型（或其扩展）的非类型成员，则是类型定义。

<!--
If there is no suitable `@reentrant` attribute, an actor-isolated declaration is reentrant.
-->

如果没有合适的 `@reentrant` 注解，被 actor 隔离的声明就是可重入的。

<!--
Here's an example illustrating how the `@reentrant` attribute can be applied at various points:
-->

下面有一个例子，说明如何在不同地方使用 `@reentrant` 注解：

```swift
actor Stage {
  @reentrant(never) func f() async { ... }    // not reentrant
  func g() async { ... }                      // reentrant
}

@reentrant(never)
extension Stage {
  func h() async { ... }                      // not reentrant
  @reentrant func i() async { ... }           // reentrant

  actor InnerChild {                          // reentrant, not affected by enclosing extension
    func j() async { ... }                    // reentrant
  }

  nonisolated func k() async { .. }     // okay, reentrancy is uninteresting
  nonisolated @reentrant func l() async { .. } // error: @reentrant on non-actor-isolated
}

@reentrant func m() async { ... } // error: @reentrant on non-actor-isolated
```

<!--
The attribute approach is not the only possible design here. At an implementation level, the actual blocking will be handled at each asynchronous call site. Instead of an attribute that affects potentially many asynchronous calls, we could introduce a different form of `await` that does the blocking, e.g.,
-->

注解不是这里唯一可能的设计方向。在实现层面上，实际的阻塞将在每个异步调用点处理。我们可以引入一个不同形式的 `await` 来进行阻塞，而不是一个可能影响许多异步调用的注解，例如：

```swift
await(blocking) friend.tell(opinion, heldBy: self)
```

### Task-chain reentrancy

<!--
The discussion of reentrant and non-reentrant actors treats reentrancy as a binary choice, where all forms of reentrancy are considered to be equally likely to introduce hard-to-reason-about data races. However, a frequent and usually quite understandable way of interacting between actors which are simply "conversations" between two or more actors in order fo fulfill some initial request. In synchronous code, it's common to have two or more different classes call back into each other with synchronous calls. For example, here is a silly implementation of `isEven` that uses mutual recursion between two classes:
-->

关于可重入和不可重入 actor 的讨论都将重入视为一种二元选择，所有形式的重入都被认为是同样可能引入难以解释的数据竞赛。然而，常见的、通常很容易理解的 actor 之间的交互方式，它只是两个或多个 actor 之间的"对话"，以实现一些原始的请求。在同步代码中，让两个或多个不同的 class 以同步调用的方式相互回调是很常见的。例如，这里是 `isEven` 的一个愚蠢的实现，它在两个 class 之间使用了相互递归：

```swift
class OddOddySync {
  let evan: EvenEvanSync!

  func isOdd(_ n: Int) -> Bool {
    if n == 0 { return true }
    return evan.isEven(num - 1)
  }
}

class EvenEvanSync {
  let oddy: OddOddySync!

  func isEven(_ n: Int) -> Bool {
    if n == 0 { return false }
    return oddy.isOdd(num - 1)
  }
}
```

<!--
This code is depending on the two methods of these classes to effectively be "reentrant" within the same call stack, because one will call into the other (and vice-versa) as part of the computation. Now, take this example and make it asynchronous using actors:
-->

这段代码依赖于这些 class 的两个方法在同一个调用堆栈中有效的"可重入"，因为其中一个会调用到另一个（反之亦然）作为计算的一部分。现在，以这个例子为例，用 `actor` 使其成为异步的：

```swift
@reentrant(never)
actor OddOddy {
  let evan: EvenEvan!

  func isOdd(_ n: Int) async -> Bool {
    if n == 0 { return true }
    return await evan.isEven(num - 1)
  }
}

@reentrant(never)
actor EvenEvan {
  let oddy: OddOddy!

  func isEven(_ n: Int) async -> Bool {
    if n == 0 { return false }
    return await oddy.isOdd(num - 1)
  }
}
```

<!--
Under `@reentrant(never)`, this code will deadlock, because a call from `EvanEvan.isEven` to `OddOddy.isOdd` will then depend on another call to `EvanEvan.isEven`, which cannot proceed until the original call completes. One would need to make these methods to be reentrant to eliminate the deadlock.
-->

在 `@reentrant(never)` 下，这段代码会出现死锁，因为从 `EvanEvan.isEven` 到 `OddOddy.isOdd` 的调用将依赖于对 `EvanEvan.isEven` 的另一次调用，在原始调用完成之前，无法继续。我们需要使这些方法成为可重入的，以消除死锁。

<!--
With Swift embracing [Structured Concurrency][sc] as a core building block of its concurrency story, we may be able to do better than outright banning reentrancy. In Swift, every asynchronous operation is part of a `Task` which encapsulates the general computation taking place, and every asynchronous operation spawned from such task becomes a child task of the current task. Therefore, it is possible to know whether a given asynchronous call is part of the same task hierarchy, which is the rough equivalent to being in the same call stack in synchronous code.
-->

随着 Swift 将[结构化并发][sc]作为其并发功能的核心组件，我们可能会比直接禁止重入做得更好。在 Swift 中，每个异步操作都是 `Task` 的一部分，`Task` 封装了正在进行的一般计算，从这种任务中产生的每个异步操作都成为当前任务的一个子任务。因此，可以知道某个异步调用是否属于同一个任务层次，这大致相当于在同步代码中处于同一个调用栈。

<!--
We could introduce a new kind of reentrancy, *task-chain reentrancy*, which allows reentrant calls on behalf of the given task or any of its children. This resolves both the deadlock we encountered in the `convinceOtherwise` example from the section on [deadlocks](#deadlocks-with-non-reentrant-actors) as well as the mutually-recursive `isEven` example above, while still preventing reentrancy from unrelated tasks. This reentrancy therefore mimics synchronous code more closely, eliminating many deadlocks without allowing unrelated interleavings to break the high-level invariants of an actor.
-->

我们可以引入一种新的重入，*任务链重入*，它允许代表给定任务或其任何子任务的重入调用。这既解决了我们在 [deadlocks](#deadlocks-with-non-reentrant-actors) 一节中的 `convinceOtherwise` 例子中遇到的死锁，也解决了上面 `isEven` 例子中的相互递归，同时还能防止不相关任务的再入。因此，这种重入更接近于模仿同步代码，消除了许多死锁，而不需要允许无关的交织执行破坏 actor 的高层不变性。

<!--
There are a few reasons why we are not currently comfortale including task-chain reentrancy in the proposal:
-->

我们目前没有把任务链重入性纳入到提案中有这几个原因：

<!--
* The task-based reentrancy approach doesn't seem to have been tried at scale. Orleans documents support for [reentrancy in a call chain](https://dotnet.github.io/orleans/docs/grains/reentrancy.html#reentrancy-within-a-call-chain), but the implementation was fairly limited and it was eventually [removed](https://twitter.com/reubenbond/status/1349725703634251779). From the Orleans experience, it is hard to assess whether the problem is with the idea or the specific implementation.
* We do not yet know of an efficient implementation technique for this approach within the actor runtime.
-->

* 基于任务的重入方法似乎还没有被大规模地尝试过。Orleans 记录了对[调用链中的重入的支持](https://dotnet.github.io/orleans/docs/grains/reentrancy.html#reentrancy-within-a-call-chain)，但实施相当有限，最终被[删除](https://twitter.com/reubenbond/status/1349725703634251779)。从 Orleans 的经验来看，很难评估问题是出在想法上还是具体的实现上。
* 我们还不知道这种方法在 actor 运行时中的有效实现方式。

<!--
If we can address the above, task-chain reentrancy can be introduced into the actor model with another spelling of the reentrancy attribute such as `@reentrant(task)`, and may provide the best default.
-->

如果我们能够解决上述问题，任务链重入可以通过重入属性的另一种参数，如 `@reentrant(task)`，引入到 actor 模型中，并可能提供最佳的默认值。

## 其它替代方案

### Actor 继承

<!--
Earlier pitches and the first reviewed version of this proposal allowed actor inheritance. Actor inheritance followed the rules of class inheritance, albeit with specific additional rules required to maintain actor isolation:
-->

早期的草案和本提案的第一个版本允许 actor 继承。Actor 的继承遵循 class 的继承规则，尽管有特定的额外规则来维持 actor 的隔离：

<!--
* An actor could not inherit from a class, and vice-versa.
* An overriding declaration must not be more isolated than the overridden declaration.
-->

* 一个 actor 不能继承于一个 class ，反之亦然。
* 一个 override 的声明不能比被 override 的声明的隔离等级高。

<!--
Subsequent review discussion determined that the conceptual cost of actor inheritance outweighed its usefulness, so it has been removed from this proposal. The form that actor inheritance would take in the language is well-understand from prior iterations of this proposal and its implementation, so this feature could be re-introduced at a later time.
-->

随后的审查讨论确定，actor 继承的概念成本超过了它的实用性，所以它已经从这个提案中删除。actor 继承在语言中采取的形式，在本提案的先前迭代和实施中已被充分理解，所以这一特性可以在以后重新引入。

### 跨 actor lets

<!--
This proposal requires cross-actor access to `let` properties to be asynchronous, which is consistent with `var` properties. Because `let` properties are immutable, accessing from outside of the actor's concurrency domain is safe, so `let` properties could implicitly be non-isolated. This would allow code such as the following:
-->

这个建议要求对 `let` 属性的跨 actor 访问是异步的，这与 `var` 属性一致。因为 `let` 属性是 immutable 的，从 actor 的并发域之外访问是安全的，所以 `let` 属性可以默认为 non-isolated。这将允许以下的代码：

```swift
actor BankAccount {
  let accountNumber: Int
}

func print(account: BankAccount) {
  print(account.accountNumber) // okay with this change: synchronous access to an actor's let property is safe
}  
```

<!--
There are some down sides to such a change. For example, it would prevent one from evolving a `let` into a `var` without breaking clients, e.g., 
-->

这样的改动会带来一些缺点。例如，它将阻止人们在不破坏客户端的情况下将 `let` 演变为 `var`，例如：

```swift
actor BankAccount {
  private(set) var accountNumber: Int  // changing 'let' to 'var' breaks clients synchronously accessing data
}
```

<!--
The actors proposal by itself does not provide any means for synchronous access to `let` properties (or anything else within an actor). The proposal on [controlling actor isolation][isolationcontrol] allows one to mark `let` declarations as `nonisolated`:
-->

Actor 提案本身并没有为同步访问 `let` 属性（或 actor 中的其他东西）提供任何方法。关于[控制 actor 隔离][isolationcontrol]的提议允许人们将 `let` 声明标记为 `nonisolated`。

```swift
actor BankAccount {
  nonisolated let accountNumber: Int
}

func print(account: BankAccount) {
  print(account.accountNumber) // okay: synchronous access to an actor's let property marked as 'nonisolated'
}  
```

## Revision history

* Changes in the final accepted version of the proposal:
  * Cross-actor references to instance `let` properties must be asynchronous.
* Changes in the second reviewed proposal:
  * Escaping closures can now be actor-isolated; only `@Sendable` prevents isolation.
  * Removed actor inheritance. It can be considered at some future point.
  * Added "cross-actor lets" to Alternatives Considered. While there is no change to the proposed direction, the issue is explained here for further discussion.
  * Replaced `Task.runDetached` with `detach` to match updates to the [Structured Concurrency proposal][sc].
* Changes in the seventh pitch:
  * Removed isolated parameters and `nonisolated` from this proposal. They'll come in a follow-up proposal on [controlling actor isolation][isolationcontrol].
* Changes in the sixth pitch:
  * Make the instance requirements of `Actor` protocols actor-isolated to `self`, and allow actor types to conform to such protocols using actor-isolated witnesses.
  * Reflow the "Proposed Solution" section to get the bigger ideas out earlier.
  * Remove `nonisolated(unsafe)`.
* Changes in the fifth pitch:
  * Drop the prohibition on having multiple `isolated` parameters. We don't need to ban it.
  * Add the `Actor` protocol back, as an empty protocol whose details will be filled in with a subsequent proposal for [custom executors][customexecs].
  * Replace `ConcurrentValue` with `Sendable` and `@concurrent` with `@Sendable` to track the evolution of [SE-0302][se302].
  * Clarify the presentation of actor isolation checking.
  * Add more examples for non-isolated declarations.
  * Added a section on isolated or "sync" actor types.
* Changes in the fourth pitch:
  * Allow cross-actor references to actor properties, so long as they are reads (not writes or `inout` references)
  * Added `isolated` parameters, to generalize the previously-special behavior of `self` in an actor and make the semantics of `nonisolated` more clear.
  * Limit `nonisolated(unsafe)` to stored instance properties. The prior definition was far too broad.
  * Clarify that `super` is isolated if `self` is.
  * Prohibit references to actor-isolated declarations in key paths.
  * Clarify the behavior of partial applications.
  * Added a "future directions" section describing isolated protocol conformances.
* Changes in the third pitch:
  * Narrow the proposal down to only support re-entrant actors. Capture several potential non-reentrant designs in the Alternatives Considered as possible future extensions.
  * Replaced `@actorIndependent` attribute with a `nonisolated` modifier, which follows the approach of `nonmutating` and ties in better with the "actor isolation" terminology (thank you to Xiaodi Wu for the suggestion).
  * Replaced "queue" terminology with the more traditional "mailbox" terminology, to try to help alleviate confusion with Dispatch queues.
  * Introduced "cross-actor reference" terminology and the requirement that cross-actor references always traffic in `Sendable` types.
  * Reference `@concurrent` function types from their separate proposal.
  * Moved Objective-C interoperability into its own section.
  * Clarify the "class-like" behaviors of actor types, such as satisfying an `AnyObject` conformance.
* Changes in the second pitch:
  * Added a discussion of the tradeoffs with actor reentrancy, performance, and deadlocks, with various examples, and the addition of new attribute `@reentrant(never)` to disable reentrancy at the actor or function level.
  * Removed global actors; they will be part of a separate document.
  * Separated out the discussion of data races for reference types.
  * Allow asynchronous calls to synchronous actor methods from outside the actor.
  * Removed the `Actor` protocol; we'll tackle customizing actors and executors in a separate proposal.
  * Clarify the role and behavior of actor-independence.
  * Add a section to "Alternatives Considered" that discusses actor inheritance.
  * Replace "actor class" with "actor".
* Original pitch [document](https://github.com/DougGregor/swift-evolution/blob/6fd3903ed348b44496b32a39b40f6b6a538c83ce/proposals/nnnn-actors.md)


[sc]: https://github.com/apple/swift-evolution/blob/main/proposals/0304-structured-concurrency.md
[se302]: https://github.com/apple/swift-evolution/blob/main/proposals/0302-concurrent-value-and-concurrent-closures.md
[customexecs]: https://github.com/rjmccall/swift-evolution/blob/custom-executors/proposals/0000-custom-executors.md
[isolationcontrol]: https://github.com/DougGregor/swift-evolution/blob/actor-isolation-control/proposals/nnnn-actor-isolation-control.md