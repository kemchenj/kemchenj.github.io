---
title: "【译】SE-0302 Sendable 和 @Sendable 闭包"
date: 2022-01-07
---

> 原文链接：[SE-0302 Sendable and @Sendable closures](https://github.com/apple/swift-evolution/blob/main/proposals/0302-concurrent-value-and-concurrent-closures.md)

* Proposal: [SE-0302](0302-concurrent-value-and-concurrent-closures.md)
* Authors: [Chris Lattner](https://github.com/lattner), [Doug Gregor](https://github.com/douggregor)
* Review Manager: [John McCall](https://github.com/rjmccall)
* Status: **Accepted (2021-03-16)**
* Implementation: [apple/swift#35264](https://github.com/apple/swift/pull/35264)
* Major Contributors: Dave Abrahams, Paul Cantrell, Matthew Johnson, John McCall
* Review: ([first review](https://forums.swift.org/t/se-0302-Sendable-and-concurrent-closures/44919)) ([revision announcement](https://forums.swift.org/t/returned-for-revision-se-0302-concurrentvalue-and-concurrent-closures/45251)) ([second review](https://forums.swift.org/t/se-0302-second-review-sendable-and-sendable-closures/45253)) ([acceptance](https://forums.swift.org/t/accepted-se-0302-sendable-and-sendable-closures/45786))

<!--
## Contents

  * [Introduction](#introduction)
  * [Motivation](#motivation)
     * [<g-emoji class="g-emoji" alias="sparkling_heart" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f496.png">💖</g-emoji> Swift   Value Semantics](#-swift--value-semantics)
     * [Value Semantic Composition](#value-semantic-composition)
     * [Higher Order Functional Programming](#higher-order-functional-programming)
     * [Immutable Classes](#immutable-classes)
     * [Internally Synchronized Reference Types](#internally-synchronized-reference-types)
     * [“Transferring” Objects Between Concurrency Domains](#transferring-objects-between-concurrency-domains)
     * [Deep Copying Classes](#deep-copying-classes)
     * [Motivation Conclusion](#motivation-conclusion)
  * [Proposed Solution   Detailed Design](#proposed-solution--detailed-design)
     * [Marker Protocols](#marker-protocols)
     * [Sendable Protocol](#sendable-protocol)
        * [Tuple conformance to Sendable](#tuple-conformance-to-sendable)
        * [Metatype conformance to Sendable](#metatype-conformance-to-sendable)
        * [Sendable conformance checking for structs and enums](#sendable-conformance-checking-for-structs-and-enums)
        * [Implicit struct/enum conformance to Sendable](#implicit-structenum-conformance-to-sendable)
        * [Sendable conformance checking for classes](#sendable-conformance-checking-for-classes)
        * [Actor types](#actor-types)
        * [Key path literals](#key-path-literals)
     * [New @Sendable attribute for functions](#new-sendable-attribute-for-functions)
        * [Inference of @Sendable for Closure Expressions](#inference-of-sendable-for-closure-expressions)
     * [Thrown errors](#thrown-errors)
     * [Adoption of Sendable by Standard Library Types](#adoption-of-sendable-by-standard-library-types)
     * [Support for Imported C / Objective-C APIs](#support-for-imported-c--objective-c-apis)
  * [Future Work / Follow-on Projects](#future-work--follow-on-projects)
     * [Adaptor Types for Legacy Codebases](#adaptor-types-for-legacy-codebases)
     * [Objective-C Framework Support](#objective-c-framework-support)
     * [Interaction of Actor self and @Sendable closures](#interaction-of-actor-self-and-sendable-closures)
     * [Marker protocols as custom attributes](#marker-protocols-as-custom-attributes)
  * [Source Compatibility](#source-compatibility)
  * [Effect on API resilience](#effect-on-api-resilience)
  * [Alternatives Considered](#alternatives-considered)
     * [Exotic Type System Features](#exotic-type-system-features)
     * [Support an explicit copy hook](#support-an-explicit-copy-hook)
  * [Conclusion](#conclusion)
  * [Revision history](#revision-history)
-->

## 简介

<!--
A key goal of the Swift Concurrency effort is to “provide a mechanism for isolating state in concurrent programs to eliminate data races.”  Such a mechanism will be a major progression for widely used programming languages — most of them provide concurrent programming abstractions in a way that subjects programmers to a wide range of bugs, including race conditions, deadlocks and other problems.
-->

Swift Concurrency 的其中一个关键目标就是“提供一种机制来隔离并发程序中的状态，以消除 data races”。这样的机制将会是通用编程语言的一次重大进步 -- 大多数语言提供的并发编程抽象会使程序员面临范围宽广的 bug，包括 race conditions，死锁和其它问题。

<!--
This proposal describes an approach to address one of the challenging problems in this space — how to type check value passing between structured concurrency constructs and actors messages. As such, this is a unifying theory that provides some of the underlying type system mechanics that make them both safe and work well together.
-->

这个提案里描述了一种方式，去解决这个领域面临的其中一个问题 -- 如何对结构化并发和 Actor 消息传递的值进行类型检查。因此，这是一个统一的理论，它提供了一些基本的类型系统机制，使它们既保障安全又能很好地协同工作。

<!--
This implementation approach involves a marker protocol named `Sendable`, as well as a `@Sendable` attribute that may be applied to functions.
-->

这种实现方式会提供一个名为 `Sendable` 的m arker 协议，以及一个可应用于函数的 `@Sendable` 注解。

<!--more-->

## 背景故事

<!--
Each actor instance and structured concurrency task in a program represents an “island of single threaded-ness”, which makes them a natural synchronization point that holds a bag of mutable state. These perform computation in parallel with other tasks, but we want the vast majority of code in such a system to be synchronization free — building on the logical independence of the actor, and using its mailbox as a synchronization point for its data.
-->

程序中的每个 actor 实例和结构化并发任务都代表着一个"单线程性的孤岛"（island of single threaded-ness），这使得它们成为一个自然的同步点，持有一系列可变的状态。这些任务与其他任务并行进行计算，但我们希望这样一个系统中的绝大多数代码都是非同步的 -- 建立在 actor 的逻辑独立性之上，将其邮箱作为数据的同步点。

<!--
As such, a key question is: “when and how do we allow data to be transferred between concurrency domains?” Such transfers occur in arguments and results of actor method calls and tasks created by structured concurrency, for example.
-->

因此，一个关键问题是："我们何时以及如何允许数据在并发域之间传输？" 例如，这种转移发生在 actor 方法调用的参数和返回值中，以及由结构化并发创建的任务中。

<!--
The Swift Concurrency features aspire to build a safe and powerful programming model. We want to achieve three things:
-->

Swift Concurrency 的功能渴望建立一个安全而强大的编程模型。我们希望实现这三件事：

<!--
1. We want Swift programmers to get a static compiler error when they try to pass across concurrency domains that could introduce unprotected shared mutable state.
2. We want advanced programmers to be able to implement libraries with sophisticated techniques (e.g. a concurrent hash table) that can be used in a safe way by others.
3. We need to embrace the existing world, which contains a lot of code that wasn’t designed with the Swift Concurrency model in mind. We need a smooth and incremental migration story.
-->

1. 我们希望 Swift 程序员在试图 跨并发域传递 可能引入不受保护的共享可变状态 时得到一个静态的编译器错误。
2. 我们希望高阶程序员能够实现包含复杂技术的库（例如并 ConcurrentHashTable），并且能够让其他人以一种安全的方式去使用。
3. 我们需要拥抱现有的世界，其中包含了很多在设计时没有考虑到 Swift 并发模型的代码。我们需要一个平滑和渐进的迁移策略。

<!--
Before we jump into the proposed solution, let’s take a look at some common cases that we would like to be able to model along with the opportunities and challenges of each. This will help us reason about the design space we need to cover.
-->

在我们进入提议的解决方案之前，先看一下我们希望能够建模的一些常见案例，以及每个案例中包含的改进机会和挑战。这将有助于推理出我们需要覆盖的设计空间。

### 💖 Swift + 值语义

<!--
The first kind of type we need to support are simple values like integers. These can be trivially passed across concurrency domains because they do not contain pointers.
-->

我们需要支持的第一种类型是像 Integer 这样的简单值。这些类型可以简单地跨并发域传递，因为它们不包含指针。

<!--
Going beyond this, Swift has a strong emphasis on types with [value semantics](https://en.wikipedia.org/wiki/Value_semantics), which are safe to transfer across concurrent boundaries. Except for classes, Swift’s mechanisms for type composition provide value semantics when their elements do. This includes generic structs, as well as its core collections: for example, `Dictionary<Int, String>` can be directly shared across concurrency domains. Swift’s Copy on Write approach means that collections can be transferred without proactive data copying of their representations — an extremely powerful fact that I believe will make the Swift concurrency model more efficient than other systems in practice.
-->

除此之外，Swift 还非常强调具有[值语义](https://en.wikipedia.org/wiki/Value_semantics)的类型，这些类型可以安全地跨并发边界传输。除了 class 之外，Swift 的类型组合机制在其元素提供值语义时也提供值语义。这包含了通用的结构，以及其核心集合：例如 `Dictionary<Int, String>` 就可以直接跨并发域共享。Swift 的 Copy on Write 机制意味着可以在不主动复制数据的情况下传输集合，这是一个非常强大的事实，我相信这将使 Swift 的并发模型在实践中比其他系统更加高效。

<!--
However, everything isn’t simple here: the core collections can **not** be safely transferred across concurrency domains when they contain general class references, closures that capture mutable state, and other non-value types. We need a way to differentiate between the cases that are safe to transfer and those that are not.
-->

然而，这里描述的一切并不简单：当核心集合包含了一般的 class 引用，捕获可变状态的闭包以及其他非值类型时，它们**不能**安全地跨并发域传输。我们需要一种方法来区分那些 可以安全转移的情况 和 不能安全转移的情况。

### 值语义的组合

<!--
Structs, enums and tuples are the primary mode for composition of values in Swift. These are all safe to transfer across concurrency domains — so long as the data they contain is itself safe to transfer.
-->

struct、enum 和 tuple 是 Swift 数值组合的主要模式。这些都可以安全地跨并发域传输 -- 只要它们包含的数据本身可以安全地传输。

### 高阶函数编程

<!--
It is common in Swift and other languages with functional programming roots to use [higher-order programming](https://en.wikipedia.org/wiki/Higher-order_function), where you pass functions to other functions.  Functions in Swift are reference types, but many functions are perfectly safe to pass across concurrency domains — for example, those with an empty capture list.
-->

在 Swift 和其他具有函数式编程基础的语言中，使用[高阶编程](https://en.wikipedia.org/wiki/Higher-order_function)是很常见的，即把函数传递给其他函数。Swift 中的函数是引用类型，但许多函数是完全可以跨并发域传递的 -- 例如，那些没有捕获变量的函数。

<!--
There are many useful reasons why you’d want to send bits of computation between concurrency domains in the form of a function — even trivial algorithms like `parallelMap` need this.  This occurs at larger scale as well — for example, consider an actor example like this:
-->

你会有很多很多合理的理由，想要在并发域之间以函数的形式发送计算过程 -- 即使是像 `parallelMap` 这样的微不足道的算法也需要。这在更大规模的计算里也会发生 -- 例如，考虑这样一个 actor 的例子：

```swift
actor MyContactList {
  func filteredElements(_ fn: (ContactElement) -> Bool) async -> [ContactElement] { … }
}
```

<!--
Which could then be used like so:
-->

能够像这样使用：

```swift
// 没有捕获变量的闭包是没问题的！
list = await contactList.filteredElements { $0.firstName != "Max" }

// 捕获了一个 `searchName` 字符串变量的闭包也是可以的
// 因为 String 是可以跨并发域传递的
list = await contactList.filteredElements {
  [searchName] in $0.firstName == searchName
}
```

<!--
We feel that it is important to enable functions to be passed across concurrency domains, but we are also concerned that we should not allow capturing local state _by reference_ in these functions, and we should not allow capturing unsafe things by value.  Both would introduce memory safety problems.
-->

我们觉得让函数跨并发域传递是很重要的，但是同时我们也有顾虑，我们不应该允许在这些函数中**通过引用**来捕获本地状态，也不应该允许通过值来捕获不安全的东西。这两者都会带来内存安全问题。

### 不可变 class

<!--
One common and efficient design pattern in concurrent programming is to build immutable data structures — it is perfectly safe to transfer a reference to a class across concurrency domains if the state within it never mutates. This design pattern is extremely efficient (no synchronization beyond ARC is required), can be used to build [advanced data structures](https://en.wikipedia.org/wiki/Persistent_data_structure), and is widely explored by the pure-functional language community.
-->

并发编程中一个常见的高效设计模式是建立不可变的数据结构 -- 如果一个类中的状态永远不会发生变化，那么在不同的并发域中传输对该类的引用是完全安全的。这种设计模式非常高效（不需要 ARC 以外的同步），可以用来构建[高级数据结构](https://en.wikipedia.org/wiki/Persistent_data_structure)，这种模式被纯函数式语言社区广泛采用。

### 内部同步的引用类型

<!--
A common design pattern in concurrent systems is for a class to provide a “thread-safe” API: they protect their state with explicit synchronization (mutexes, atomics, etc). Because the public API to the class is safe to use from multiple concurrency domains, the reference to the class can be directly transferred safely.
-->

并发系统中另一种常见的设计模式就是让一个类提供一个“线程安全”的 API：它们用显式同步（mutexes、atomics 等）来保护它们的状态。因为该类的公开 API 可以从多个并发域中安全使用，所以对该类的引用可以安全地直接转移。

<!--
References to actor instances themselves are an example of this: they are safe to pass between concurrency domains by passing a pointer, since the mutable state within an actor is implicitly protected by the actor mailbox.
-->

对 actor 实例本身的引用就是一个例子：通过传递指针，它们可以在并发域之间安全传递，因为 actor 内部的可变状态是由 actor 邮箱隐式保护的。

### 在并发域之间"传递"对象

<!--
A fairly common pattern in concurrent systems is for one concurrency domain to build up a data structure containing unsynchronized mutable state, then “hand it off” to a different concurrency domain to use by transferring the raw pointer. This is correct without synchronization if (and only if) the sender stops using the data that it built up — the result is that only the sender or receiver dynamically accesses the mutable state at a time.
-->

并发系统中的一种相当常见的模式是，一个并发域建立了一个包含非同步的 可变状态的 数据结构，然后通过传输原始指针将其"移交"给另一个并发域使用。如果（也只有在）发送方停止使用已移交的数据时，这在没有同步的情况下也是正确的 -- 结果是每次只有发送方或接收方动态地访问可变状态。

<!--
There are both safe and unsafe ways to achieve this, e.g. see the discussion about “exotic” type systems in the [Alternatives Considered](#alternatives-considered) section at the end.
-->

既有安全也有不安全的方式来实现这一点，例如，请看最后的其它备选方案部分中关于"奇异的类型系统功能“的讨论。

### 深拷贝的 Class

<!--
One safe way to transfer reference types is to make a deep copy of the data structures, ensuring that the source and destination concurrency domains each have their own copy of mutable state. This can be expensive for large structures, but is/was commonly used in some Objective-C frameworks.  General consensus is that this should be _explicit_, not something implicit in the definition of a type.
-->

转移引用类型的一种安全方式是对数据结构进行深度复制，确保源并发域和目标并发域都有自己的可变状态副本。这对大型结构来说可能很昂贵，但在一些 Objective-C 框架中是或曾经是常用的。一般的共识是，这应该是显式的，而不是隐含在类型定义中的东西。

### 总结

<!--
This is just a sampling of patterns, but as we can see, there are a wide range of different concurrent design patterns in widespread use. The design center of Swift around value types and encouraging use of structs is a very powerful and useful starting point, but we need to be able to reason about the complex cases as well — both for communities that want to be able express high performance APIs for a given domain but also because we need to work with legacy code that won’t get rewritten overnight.
-->

这只是一些模式的范例，但我们可以看到，有很多不同的并发设计模式在广泛使用。Swift 的设计中心围绕着值类型和鼓励使用 struct 形成了一个非常强大和有利的起点，但是我们也需要能够推导出复杂的情况 -- 这既是为了那些希望能够为特定领域编写高性能 API 的社区，也是因为我们需要处理那些 不可能在一夜之间被重写的遗留代码。

<!--
As such, it is important to consider approaches that allow library authors to express the intent of their types, it is important for app programmers to be able to work with uncooperative libraries retroactively, and it is also important that we provide safety as well as unsafe escape hatches so we can all just “get stuff done” in the face of an imperfect world that is in a process of transition.
-->

因此，允许库作者表达其类型意图的方法是很重要的，应用开发者能够与现有不兼容的库一起相处也是很重要的，而且我们不仅需要提供安全的方式，也需要不安全的方式，这个世界正处于过渡阶段，我们需要在这个不完美的世界里"把任务完成"。

<!--
Finally, our goal is for Swift (in general and in this specific case) to be a highly principled system that is sound and easy to use. In 20 years, many new libraries will be built for Swift and its ultimate concurrency model. These libraries will be built around value semantic types, but should also allow expert programmers to deploy state of the art techniques like lock-free algorithms, use immutable types, or whatever other design pattern makes sense for their domain. We want users of these APIs to not have to care how they are implemented internally.
-->

最后，我们的目标是让 Swift（在一般情况下和在这个特定情况下）成为一个高度统一的系统，健全且易于使用。未来 20 年，许多新的库将会基于 Swift 及其最终的并发模型建立。这些库将围绕值语义类型建立，但也应该允许高级程序员部署最先进的技术，如无锁算法，使用不可变类型，或任何其它对他们的领域有意义的设计模式。我们希望这些 API 的用户不必关心它们在内部的实现方式。

## 解决方案 + 具体设计

<!--
The high level design of this proposal revolves around a `Sendable` marker protocol, adoption of `Sendable` by standard library types, and a new `@Sendable` attribute for functions.
-->

这个提案的上层设计围绕着一个名为 `Sendable` 的 marker 协议，标准库类型将会全面采用 `Sendable` 协议，以及一个新的 `@Sendable` 函数注解。

<!--
Beyond the basic proposal, in the future it could make sense to add a set of adapter types to handle legacy compatibility cases, and first class support for Objective-C frameworks.  These are described in the following section.
-->

除了基本的提案，在未来，有可能增加一组 Adapter 类型来处理遗留代码的兼容，以及对 Objective-C 框架的一级支持。这些将在下一节中讨论。

### Marker 协议类型

<!--
This proposal introduces the concept of a “marker” protocol, which indicates that the protocol has some semantic property but is entirely a compile-time notion that does not have any impact at runtime.  Marker protocols have the following restrictions:
-->

本提案将引入 `marker` 协议的概念，这表明该协议具有某种语义属性，但完全是一个编译时的概念，在运行时没有任何影响。marker 协议有以下限制：

<!--
*   They cannot have requirements of any kind.
*   They cannot inherit from non-marker protocols.
*   A marker protocol cannot be named as the type in an `is` or `as?` check (e.g., `x as? Sendable` is an error).
*   A marker protocol cannot be used in a generic constraint for a conditional protocol conformance to a non-marker protocol.
-->

* 它们不能有任何形式的实现要求。
* 它们不能继承非 marker 协议。
* marker 协议不能作为类型使用 `is` 或 `as?` 进行检查（例如，`x as? Sendable` 是一个错误）。
* marker 协议不能用于非 marker 协议的 conditional conformance 约束中。

<!--
We think this is a generally useful feature, but believe it should be a compiler-internal feature at this point.  As such, we explain it and use this concept with the “`@_marker`” attribute syntax below.
-->

我们认为这是一个通用的特性，但认为在这一点上它应该是一个编译器内部的特性。因此，我们在下面对它进行了解释，并通过 `@_marker` 注解语法来表达这个概念。

### `Sendable` 协议

<!--
The core of this proposal is a marker protocol defined in the Swift standard library , which has special conformance checking rules:
-->

这个提案的核心是 Swift 标准库中定义的一个 marker 协议，它具有特殊的 conformance 检查规则：

```swift
@_marker
protocol Sendable {}
```

<!--
It is a good idea for types to conform to the `Sendable` protocol when they are designed so all of their public API is safe to use across concurrency domains.  This is true for example, when there are no public mutators, if public mutators are implemented with COW, or if they are implemented with internal locking or some other mechanism.  Types may of course have internal implementation details based on local mutation if they have locking or COW as part of their public API.
-->

当一个类型，其所有的 public API 都被设计成可以安全地跨并发域使用时，让它遵循 `Sendable` 协议就是个正确的选择。例如，当没有 public mutator 时，或者 public mutator 是用 COW 实现的，亦或者它们是用内部锁或其他机制实现的。类型当然也可以有本地 mutation 的内部实现细节，只要将 lock 或 COW 作为其公共 API 的一部分。

<!--
The compiler rejects any attempts to pass data across concurrency domains, e.g. rejecting cases where the argument or result of an actor message send or structured concurrency call does not conform to the `Sendable` protocol:
-->

编译器拒绝任何跨并发域传递数据的尝试，例如，actor 消息发送，结构化并发调用的参数或返回值不符合 `Sendable` 协议，这些情况都会遭到拒绝：

```swift
actor SomeActor {
  // async functions are usable *within* the actor, so this
  // is ok to declare.
  // async 函数会在 actor 内部调用的，所以这是可以声明的
  func doThing(string: NSMutableString) async {...}
}

// ... but they cannot be called by other code not protected
// by the actor's mailbox:
// ... 但如果它们从不被 actor 邮箱保护的地方被其它代码调用：
func f(a: SomeActor, myString: NSMutableString) async {
  // error: 'NSMutableString' may not be passed across actors;
  //        it does not conform to 'Sendable'
  await a.doThing(string: myString)
}
```

<!--
The `Sendable` protocol models types that are allowed to be safely passed across concurrency domains by copying the value.  This includes value-semantic types, references to immutable reference types, internally synchronized reference types, `@Sendable` closures, and potentially other future type system extensions for unique ownership etc.
-->

`Sendable` 协议用于建模那些 允许通过复制值在并发域中安全传递的类型。这包括值语义类型、对不可变引用类型的引用、内部同步的引用类型、`@Sendable` 闭包，以及未来可能的其他类型系统扩展的唯一所有权等。

<!--
Note that incorrect conformance to this protocol can introduce bugs in your program (just as an incorrect implementation of `Hashable` can break invariants), which is why the compiler checks conformance (see below).
-->

请注意，对该协议不正确的 conformance 会在你的程序中引入错误（就像对 `Hashable` 的不正确实现会破坏不变性一样），这就是为什么编译器会检查 conformance（见下文）。

#### 元组的 `Sendable` conformance

<!--
Swift has [hard coded conformances for tuples](https://github.com/apple/swift-evolution/blob/main/proposals/0283-tuples-are-equatable-comparable-hashable.md) to specific protocols, and this should be extended to `Sendable`, when the tuples elements all conform to `Sendable`.
-->

Swift 的元组有特定协议的[硬编码 conformance](https://github.com/apple/swift-evolution/blob/main/proposals/0283-tuples-are-equatable-comparable-hashable.md)，`Sendable` 也应该加入到这个规则里，当元组的元素都符合 `Sendable` 时，元祖也遵循 `Sendable`。 

#### 元类型的 `Sendable` conformance

<!--
Metatypes (such as` Int.Type`, the type produced by the expression `Int.self`) always conform to `Sendable`, because they are immutable.
-->

元类型（如 `Int.Type`，由表达式 `Int.self` 产生的类型）总是遵循 `Sendable`，因为它们是不可改变的。

#### struct 和 enum 的 `Sendable` conformance 检测

<!--
`Sendable` types are extremely common in Swift and aggregates of them are also safe to transfer across concurrency domains.  As such, the Swift compiler allows direct conformance to `Sendable` for structs and classes that are compositions of other `Sendable` types:
-->

`Sendable` 类型在 Swift 中极为常见，它们的聚合体也可以安全地跨并发域传输。因此，Swift 编译器允许作为其他 `Sendable` 类型组合出来的 struct 和 class 直接遵循 `Sendable`：

```swift
struct MyPerson : Sendable { var name: String, age: Int }
struct MyNSPerson { var name: NSMutableString, age: Int }

actor SomeActor {
  // struct 和元组可以发送和接收
  public func doThing(x: MyPerson, y: (Int, Float)) async {..}

  // 如果跨 actor 边界被调用就会出错：MyNSPerson 不遵循 Sendable！
  public func doThing(x: MyNSPerson) async {..}
}
```

<!--
While this is convenient, we would like to slightly increase friction of protocol adoption for cases that require more thought.  As such, the compiler rejects conformance of structs and enums to the `Sendable` protocol when one of their members (or associated values) does not itself conform to `Sendable` (or is not known to conform to `Sendable` through a generic constraint):
-->

虽然这很方便，但我们希望，在需要更加深思熟虑的情况下，稍微增加遵循协议的阻力。因此，当 struct 和 enum 的某个成员（或相关值）本身不符合 `Sendable` 协议（或通过约束无法推导出是否符合 `Sendable` 协议）时，编译器会拒绝让其遵循 `Sendable` 协议。

```swift
// error: MyNSPerson cannot conform to Sendable due to NSMutableString member.
// note: add '@unchecked' if you know what you're doing.
struct MyNSPerson : Sendable {
  var name: NSMutableString
  var age: Int
}

// error: MyPair cannot conform to Sendable due to 'T' member which may not itself be a Sendable
// note: see below for use of conditional conformance to model this
struct MyPair<T> : Sendable {
  var a, b: T
}

// 使用 conditional conformance 来建模泛型类型
struct MyCorrectPair<T> {
  var a, b: T
}

extension MyCorrectPair: Sendable where T: Sendable { }
```

<!--
As mentioned in the compiler diagnostic, any type can override this checking behavior by annotating the conformance to `Sendable` with `@unchecked`. This indicates that the type can safely be passed across concurrency domains, but requires the author of the type to ensure that this is safe.
-->

正如在编译器诊断信息里提到的，任何类型都可以通过用 `@unchecked` 对 `Sendable` 的 conformance 进行注解，来跳过这种检查行为。这表明该类型可以安全地跨并发域传递，但需要该类型的作者来确保这是安全的。

<!--
A `struct` or `enum` can only be made to conform to `Sendable` within the same source file in which the type was defined. This ensures that the stored properties in a struct and associated values in an enum are visible so that their types can be checked for `Sendable` conformance. For example:
-->

一个 `struct` 或 `enum` 只能在定义该类型的同一个源文件中实现 `Sendable` 的 conformance。这确保了 struct 中的存储属性和 enum 中的关联值是可见的，这样就可以检查它们的类型是否符合 `Sendable`。比如说：

```swift
// MySneakyNSPerson.swift
struct MySneakyNSPerson {
  private var name: NSMutableString
  public var age: Int
}

// 在另一个源文件或者模块中...
// error: cannot declare conformance to Sendable outside of
// the source file defined MySneakyNSPerson
extension MySneakyNSPerson: Sendable { }
```

<!--
Without this restriction, another source file or module, which cannot see the private stored property name, would conclude that `MySneakyNSPerson` is properly a `Sendable`. One can declare conformance to `Sendable` as `@unchecked` to disable this check as well:
-->

如果没有这个限制，另一个源文件或模块，无法看到私有的存储属性，就会得出结论，`MySneakyNSPerson` 可以遵循 `Sendable`。我们也可以将与 `Sendable` 的遵循声明为 `@unchecked` 来禁用这个检查：

```swift
// 在另一个源文件或者模块中...
// okay: 在另一个源文件的 unchecked 遵循是被允许的
extension MySneakyNSPerson: @unchecked Sendable { }
```

#### struct/enum 的 `Sendable` 隐式 conformance

<!--
Many structs and enums satisfy the requirements of `Sendable`, and having to explicitly write out "`: Sendable`" for every such type can feel like boilerplate. 
-->

许多 struct 和 enum 都满足 `Sendable` 的实现要求，如果需要为每个类型都明确写出 "`: Sendable`"会让人觉得是太啰嗦。

<!--
For non-public structs and enums that are also not `@usableFromInline`, and for frozen public structs and enums, the `Sendable` conformance is implicitly provided when conformance checking (described in the previous section) succeeds:
-->

对于不属于 `@usableFromInline` 的非 public struct 和 enum，以及 frozen 的 public struct 和 enum，当 conformance 检查（在上一节中描述）成功时，将隐式得遵循 `Sendable`：

```swift
struct MyPerson2 { // 隐式遵循 Sendable
  var name: String, age: Int
}

class NotConcurrent { } // 不遵循 Sendable

struct MyPerson3 { // 不遵循 Sendable 因为 nc 不是 Sendable 的类型
  var nc: NotConcurrent
}
```

<!--
Public non-frozen structs and enums do not get an implicit conformance, because doing so would present a problem for API resilience: the implicit conformance to `Sendable` would become part of the contract with clients of the API, even if it was not intended to be. Moreover, this contract could easily be broken by extending the struct or enum with storage that does not conform to `Sendable`. 
-->

public 的非 fronzen struct 和 enum 不会得到隐式的遵循，因为这样做会给 API resilience 带来问题：对 `Sendable` 的隐式的遵循会成为与 API 客户端约定的一部分，即使它不是有意的。此外，这种约定可以很容易地被破坏，因为增加 struct 或 enum 的存储属性可能会破坏 `Sendable` 的遵循。

<!--
> **Rationale**: Existing precedent from `Hashable`, `Equatable`, and `Codable` is to require explicit conformance, even when the details are synthesized. We break from that precedent for `Sendable` because (1) `Sendable` is likely to be even more common, (2) there is no impact on code size (or the binary at all) for `Sendable`, unlike with the other protocols, and (3) `Sendable` does not introduce any additional API beyond allowing the use of the type across concurrency domains.
-->

> **理由**：来自 `Hashable`、`Equatable` 和 `Codable` 的现有先例是要求有显式的 conformance ，即使实现细节会被合成。我们为 `Sendable` 打破了这个先例，因为(1) `Sendable` 可能会更加普遍，(2) `Sendable` 对代码大小（或二进制）没有影响，与其他协议不同，(3) `Sendable` 除了允许跨并发域使用该类型外，没有引入任何额外的 API。

<!--
Note that implicit conformance to `Sendable` is only available for non-generic types and for generic types whose instance data is guaranteed to be of `Sendable` type. For example:
-->

请注意，对 `Sendable` 的隐式遵循只适用于非泛型类型和实例数据保证为 `Sendable` 的泛型类型。例如：

```swift
struct X<T: Sendable> {  // 隐式遵循 Sendable
  var value: T
}

struct Y<T> {    // 无法隐式遵循 Sendable 因为 T 不遵循 Sendable
  var value: T
}
```

<!--
Swift will not implicitly introduce a conditional conformance. It is possible that this could be introduced in a future proposal.
-->

Swift 将不会隐式地引入 conditional conformance。这有可能在未来的提案中被引入。

#### class 的 `Sendable` conformance 检测

<!--
Any class may be declared to conform to `Sendable` with an `@unchecked` conformance, allowing them to be passed between actors without semantic checks.  This is appropriate for classes that use access control and internal synchronization to provide memory safety — these mechanisms cannot generally be checked by the compiler.
-->

任何 class 都可以被声明为符合 `Sendable` 的 `@unchecked` 遵循，允许它们在 actor 之间传递而不需要语义检查。这适用于使用访问权限和内部同步来提供内存安全的类 -- 这些机制一般无法通过编译器检查。

<!--
In addition, a class may conform to `Sendable` and be checked for memory safety by the compiler in a specific limited case: when the class is a final class containing only immutable stored properties of types that conform to Sendable:
-->

此外，一个 class 也许可以遵循 `Sendable`，并在特定的有限情况下通过编译器检查内存安全：当该 class 是一个 final class，只包含遵循 Sendable 的不可变存储属性：

```swift
final class MyClass : Sendable {
  let state: String
}
```

<!--
Such classes may not inherit from classes other than NSObject (for Objective-C interoperability).  `Sendable` classes have the same restriction as structs and enums that requires the `Sendable` conformance to occur in the same source file.
-->

这样的 class 不能继承于除 NSObject 以外的类（为了 Objective-C 的互操作性）。`Sendable` class 与 struct 和 enum 有相同的限制，要求 `Sendable` 的 conformance 写在同一个源文件中。

<!--
This behavior makes it possible to safely create and pass around immutable bags of shared state between actors.  There are several ways to generalize this in the future, but there are non-obvious cases to nail down.  As such, this proposal intentionally keeps safety checking for classes limited to ensure we make progress on other aspects of the concurrency design.
-->

这种行为使得在 actor 之间安全地创建和传递不可变的共享状态成为可能。在未来，有几种方法可以将其泛化，但有一些不明显的情况需要确定下来。因此，本提案有意保持对 class 的安全检查，以确保我们可以在并发性设计的其他方面取得进展。

#### Actor 类型

<!--
Actor types provide their own internal synchronization, so they implicitly conform to `Sendable`. The [actors proposal](https://github.com/apple/swift-evolution/blob/main/proposals/0306-actors.md) provides more detail.
-->

Actor 类型提供它们自己的内部同步，所以它们隐式得遵循 `Sendable`。[actors 提案](https://github.com/apple/swift-evolution/blob/main/proposals/0306-actors.md)提供了更多细节。

#### Key path 字面量

<!--
Key paths themselves conform to the `Sendable` protocol. However, to ensure that it is safe to share key paths, key path literals can only capture values of types that conform to the `Sendable` protocol. This affects uses of subscripts in key paths:
-->

Key path 本身符合 `Sendable` 协议。然而，为了确保共享 key path 的安全性，key path 字面量只能捕获符合 `Sendable` 协议的类型的值。这会影响 key path 下标的使用：

```swift
class SomeClass: Hashable {
  var value: Int
}

class SomeContainer {
  var dict: [SomeClass : String]
}

let sc = SomeClass(...)

// error: capture of 'sc' in key path requires 'SomeClass' to conform
// to 'Sendable'
let keyPath = \SomeContainer.dict[sc]
```

### 新的 `@Sendable` 函数注解

<!--
While the `Sendable` protocol directly addresses value types and allows classes to opt-in to participation with the concurrency system, function types are also important reference types that cannot currently conform to protocols. Functions in Swift occur in several forms, including global func declarations, nested functions, accessors (getters, setters, subscripts, etc), and closures.  It is useful and important to allow functions to be passed across concurrency domains where possible to allow higher order functional programming techniques in the Swift Concurrency model, for example to allow definition of `parallelMap` and other obvious concurrency constructs.
-->

虽然 `Sendable` 协议直接针对值类型，并允许 class 选择性地参与并发系统，但函数类型也是重要的引用类型，目前无法遵循协议。Swift 中的函数有几种形式，包括全局 func 声明、嵌套函数、访问器（getters、setters、subscripts 等）和闭包。在可能的情况下，允许函数跨并发域传递，以允许 Swift 并发模型中的高阶函数式编程技术，例如允许定义 `parallelMap` 和其他明显的并发结构，这是非常实用和重要的。

<!--
We propose defining a new attribute on function types named `@Sendable`.   A `@Sendable` function type is safe to transfer across concurrency domains (and thus, it implicitly conforms to the `Sendable` protocol).  To ensure memory safety, the compiler checks several things about values (e.g. closures and functions) that have `@Sendable` function type:
-->

我们建议在函数类型上定义一个名为 `@Sendable` 的新注解。一个 `@Sendable` 函数类型可以安全地跨并发域传输（因此，它隐式得遵循 `Sendable` 协议）。为了确保内存安全，编译器会对 `@Sendable` 函数类型的值（例如闭包和函数）进行若干检查：

<!--
1.  A function can be marked `@Sendable`. Any captures must also conform to `Sendable`.

2.  Closures that have `@Sendable` function type can only use by-value captures. Captures of immutable values introduced by `let` are implicitly by-value; any other capture must be specified via a capture list:

    ```swift
    let prefix: String = ...
    var suffix: String = ...
    strings.parallelMap { [suffix] in prefix + $0 + suffix }
    ```

    The types of all captured values must conform to `Sendable`.

3.  Accessors are not currently allowed to participate with the `@Sendable` system as of this proposal.  It would be straight-forward to allow getters to do so in a future proposal if there was demand for this.
-->

1. 一个函数可以被标记为 `@Sendable`。所有捕获的值都必须遵循 `Sendable`。

2. `@Sendable` 函数类型的闭包只能使用 by-value 捕获。由 `let` 引入的不可改变的值的捕获是隐含的 by-value；任何其他捕获的变量必须通过捕获列表指定：

    ```swift
    let prefix: String = ...
    var suffix: String = ...
    strings.parallelMap { [suffix] in prefix + $0 + suffix }
    ```

    所有捕获的值的类型必须遵循 `Sendable`。

3. 目前在本提案中，getter/setter 不允许参与 `@Sendable` 系统。如果有这方面的需求，可以在未来的提案里直接允许 getter 声明为 Sendable。

<!--
The `@Sendable` attribute to function types is orthogonal to the existing `@escaping` attribute, but it works the same way.  `@Sendable` functions are always subtypes of non-`@Sendable` functions, and implicitly convert when needed.  Similarly, closure expressions infer the `@Sendable` bit from context just like `@escaping` closures do.
-->

函数类型的 `@Sendable` 注解与现有的 `@escaping` 注解是正交的，但其工作方式是一样的。`@Sendable` 函数总是非 `@Sendable` 函数的子类型，并在需要时隐式地进行转换。同样地，闭包表达式从上下文中推断出 `@Sendable` 位，就像 `@escaping` 闭包所做的那样。

<!--
We can revisit the example from the motivation section — it may be declared like this:
-->

我们可以重温一下前文提到的例子 -- 它可以这样声明：

```swift
actor MyContactList {
  func filteredElements(_ fn: @Sendable (ContactElement) -> Bool) async -> [ContactElement] { … }
}
```

<!--
Which could then be used like so:
-->

然后可以像这样使用：

```swift
// 没有捕获变量的闭包是没问题的！
list = await contactList.filteredElements { $0.firstName != "Max" }

// 捕获了一个 `searchName` 字符串也是没问题的，因为字符串遵循 Sendable
// searchName 是隐式的值捕获
list = await contactList.filteredElements { $0.firstName==searchName }

// @Sendable 是类型的一部分，所以传递一个兼容的函数声明也没问题！
list = await contactList.filteredElements(dynamicPredicate)

// Error: cannot capture NSMutableString in a @Sendable closure!
list = await contactList.filteredElements {
  $0.firstName == nsMutableName
}

// Error: someLocalInt cannot be captured by reference in a
// @Sendable closure!
var someLocalInt = 1
list = await contactList.filteredElements {
  someLocalInt += 1
  return $0.firstName == searchName
}
```

<!--
The combination of `@Sendable` closures and `Sendable` types allows type safe concurrency that is library extensible, while still being easy to use and understand.  Both of these concepts are key foundations that actors and structured concurrency builds on top of.
-->

`@Sendable` 闭包和 `Sendable` 类型的组合允许类型安全的并发，它是可扩展的库，同时仍然易于使用和理解。这两个概念都是关键的基础，actor 和结构化并发都建立在其之上。

#### 闭包表达式的 `@Sendable` 推导

<!--
The inference rule for `@Sendable` attribute for closure expressions is similar to closure `@escaping` inference.  A closure expression is inferred to be `@Sendable` if:
-->

闭包表达式的 `@Sendable` 注解推导规则与闭包 `@escaping` 相似。在以下几种情况中，一个闭包表达式将被推导为 `@Sendable`：

<!--
*   It is used in a context that expects a `@Sendable` function type (e.g. `parallelMap` or `Task.runDetached`).
*   When `@Sendable` is in the closure “in” specification.
-->

* 它被用于期望有 `@Sendable` 函数类型的上下文中（例如 `parallelMap` 或 `Task.runDetached`）。
* 当 `@Sendable` 在闭包的 `in` 前进行指定。

<!--
The difference from `@escaping` is that a context-less closure defaults to be non-`@Sendable`, but defaults to being `@escaping`:
-->

与 `@escaping` 的区别在于，无上下文的闭包默认为非 `@Sendable` 的，但默认为 `@escaping`。

```swift
// defaults to @escaping but not @Sendable
let fn = { (x: Int, y: Int) -> Int in x+y }
```

<!--
Nested functions are also an important consideration, because they can also capture values just like a closure expression.  The `@Sendable` attribute is used on nested function declarations to opt-into concurrency checking:
-->

嵌套函数也是一个重要的考虑因素，因为它们也可以像闭包表达式一样捕获值。嵌套函数声明中使用了 `@Sendable` 注解来选择加入并发检查：

```swift
func globalFunction(arr: [Int]) {
  var state = 42

  // Error, 'state' is captured immutably because closure is @Sendable.
  arr.parallelForEach { state += $0 }

  // Ok, function captures 'state' by reference.
  func mutateLocalState1(value: Int) {
    state += value
  }

  // Error: non-@Sendable function isn't convertible to @Sendable function type.
  arr.parallelForEach(mutateLocalState1)

  @Sendable
  func mutateLocalState2(value: Int) {
    // Error: 'state' is captured as a let because of @Sendable
    state += value
  }

  // Ok, mutateLocalState2 is @Sendable.
  arr.parallelForEach(mutateLocalState2)
}
```

<!--
This composes cleanly for both structured concurrency and actors.
-->

这对结构化并发和 actor 来说都是干净的组合。

### Thrown errors

<!--
A function or closure that `throws` can effectively return a value of any type that conforms to the `Error` protocol. If the function is called from a different concurrency domain, the thrown value can be passed across it.
-->

一个 `throws` 的函数或闭包可以有效地返回一个符合 `Error` 协议的任何类型的值。如果该函数从不同的并发域被调用，抛出的值可以被传递到另一个作用域：

```swift
class MutableStorage {
  var counter: Int
}
struct ProblematicError: Error {
  var storage: MutableStorage
}

actor MyActor {
  var storage: MutableStorage
  func doSomethingRisky() throws -> String {
    throw ProblematicError(storage: storage)
  }
}
```

<!--
A call to `myActor.doSomethingRisky()` from another concurrency domain would throw the problematic error, capturing part of the mutable state of `myActor`, then provide it to another concurrency domain, breaking actor isolation. Because there is no information in the signature of `doSomethingRisky()` about the types of errors thrown, and an error that propagates out from `doSomethingRisky()` could come from _any_ code that the function invokes, there is no place at which we could check that only `Sendable`-conforming errors are thrown.
-->

从另一个并发域调用 `myActor.doSomethingRisky()` 会抛出有问题的 error ，它捕获了 `myActor` 的部分可变状态，然后提供给另一个并发域，破坏了 actor 的隔离。因为 `doSomethingRisky()` 的签名中没有关于抛出的 Error 类型的信息，而且从 `doSomethingRisky()` 传播出来的 error 可能来自该函数调用的任何代码，所以我们没有地方可以检查被抛出的 error 是否遵循 `Sendable`。

<!--
To close this safety hole, we alter the definition of the `Error` protocol to require that _all_ error types conform to `Sendable`:
-->

为了修复这个安全漏洞，我们改变了 `Error` 协议的定义，要求所有的 error 类型都遵循 `Sendable`。

```swift
protocol Error: Sendable { … }
```

<!--
Now, the `ProblematicError` type will be rejected with an error because it conforms to `Sendable` but contains a stored property of non-`Sendable` type `MutableStorage`.
-->

现在，`ProblematicError` 类型将被编译器拒绝并抛出错误，因为它尝试声明为 `Sendable`，但包含一个非 `Sendable` 类型 `MutableStorage` 的存储属性。

<!--
Generally speaking, one cannot add a new inherited protocol to an existing protocol without breaking both source and binary compatibility. However, marker protocols have no impact on the ABI and no requirements, so binary compatibility is maintained.
-->

一般来说，在不破坏代码和二进制兼容性的情况下，我们不能在现有的协议上添加新的协议继承。然而，marker 协议对 ABI 没有影响，也没有要求，所以二进制兼容性可以保持。

<!--
Source compatibility requires more care, however. `ProblematicError` is well-formed in today’s Swift, but will be rejected with the introduction of `Sendable`. To ease the transition, errors about types that get their `Sendable` conformances through `Error` will be downgraded to warnings in Swift &lt; 6.
-->

然而，代码兼容性还是需要更加留意。`ProblematicError` 在今天的 Swift 中是没有问题的代码，但随着 `Sendable` 的引入将被拒绝。为了便于过渡，在 Swift < 6 中，通过 `Error` 获得 `Sendable` 符合性的类型的错误将被降级为警告。

### 标准库类型全面添加 `Sendable` 的 conformance

<!--
It is important for standard library types to be passed across concurrency domains. The vast majority of standard library types provide value semantics, and therefore should conform to `Sendable`, e.g.:
-->

对于标准库类型来说，跨并发域传递是很重要的。绝大多数标准库类型提供了值语义，因此也应该遵循 `Sendable`，例如：

```swift
extension Int: Sendable {}
extension String: Sendable {}
```

<!--
Generic value-semantic types are safe to be passed across concurrency domains so long as any element types are safe to be passed across concurrency domains. This dependency can be modeled by conditional conformances:
-->

只要所有泛型参数的类型可以安全地跨并发域传递，泛型的值语义类型就可以安全地跨并发域传递。这种先决条件可以通过 conditional conformance 来进行建模：

```swift
extension Optional: Sendable where Wrapped: Sendable {}
extension Array: Sendable where Element: Sendable {}
extension Dictionary: Sendable
    where Key: Sendable, Value: Sendable {}
```

<!--
Except for the cases listed below, all struct, enum, and class types in the standard library conform to the `Sendable` protocol. Generic types conditionally conform to the `Sendable` protocol when all of their generic arguments conform to `Sendable`. The exceptions to these rules follow:
-->

除了下面列出的情况，标准库中的所有 struct、enum 和 class 的类型都将添加 `Sendable` 的 conformance。当泛型类型的所有泛型参数都遵循 `Sendable` 时，它们将有条件地遵循 `Sendable`。这些规则的例外情况如下：

<!--
*   `ManagedBuffer`: this class is meant to provide mutable reference semantics for a buffer. It must not conform to `Sendable` (even unsafely).
*   `Unsafe(Mutable)(Buffer)Pointer`: these generic types _unconditionally_ conform to the `Sendable` protocol. This means that an unsafe pointer to a non-concurrent value can potentially be used to share such values between concurrency domains. Unsafe pointer types provide fundamentally unsafe access to memory, and the programmer must be trusted to use them correctly; enforcing a strict safety rule for one narrow dimension of their otherwise completely unsafe use seems inconsistent with that design.
*   Lazy algorithm adapter types: the types returned by lazy algorithms (e.g., as the result of `array.lazy.map` { … }) never conform to `Sendable`. Many of these algorithms (like the lazy `map`) take non-`@Sendable` closure values, and therefore cannot safely conform to `Sendable`.
-->

* `ManagedBuffer`: 这个类的目的是为一个缓冲区提供可变的引用语义。它不应该遵循 `Sendable`（甚至不应该跳过检查）。
* `unsafe(Mutable)(Buffer)Pointer`：这些泛型类型**无条件地**遵循 `Sendable` 协议。这意味着一个非并发值的 unsafe pointer 有可能被用来在并发域之间共享这些值。Unsafe 的 pointer 类型从根本上提供了对内存的不安全访问，必须相信程序员能够正确地使用它们；对它们的一个狭窄的维度强制执行严格的安全规则，否则完全不安全的使用似乎与该设计不一致。
* Lazy 算法适配器类型：lazy 算法返回的类型（例如，作为 `array.lazy.map` { ... } 的结果）从不符合 `Sendable`。许多这样的算法（如 lazy 的 `map`）采取非 `@Sendable` 的闭包，因此不能安全地符合`Sendable`。

> 译者注：虽然上面提到 unsafePointer 家族的类型都无条件遵循 `Sendable` 协议，后续的提案 [SE-0331 Remove Sendable conformance from unsafe pointer types](https://github.com/apple/swift-evolution/blob/main/proposals/0331-remove-sendable-from-unsafepointer.md) 移除了这条规则，所以 unsafePointer 家族的类型现在并不遵循 `Sendable`。

<!--
The standard library protocols `Error` and `CodingKey` inherit from the `Sendable` protocol:

*   `Error` inherits from `Sendable` to ensure that thrown errors can safely be passed across concurrency domains, as discussed in the previous section.
*   `CodingKey` inherits from `Sendable` so that types like `EncodingError` and `DecodingError`, which store `CodingKey` instances, can correctly conform to `Sendable`.
-->

标准库协议 `Error` 和 `CodingKey` 都添加 `Sendable` 协议的继承：

* `Error` 继承 `Sendable`，以确保抛出的错误可以安全地跨并发域传递，如上一节所述。
* `CodingKey` 继承 `Sendable`，以便像 `EncodingError` 和 `DecodingError` 这样存储 `CodingKey` 实例的类型可以遵循 `Sendable`。

### 支持导入 C / Objective-C 的 API

<!--
Interoperability with C and Objective-C is an important part of Swift. C code will always be implicitly unsafe for concurrency, because Swift cannot enforce correct behavior of C APIs. However, we still define some basic interactions with the concurrency model by providing implicit `Sendable` conformances for many C types:

*   C enum types always conform to the `Sendable` protocol.
*   C struct types conform to the `Sendable` protocol if all of their stored properties conform to `Sendable`.
*   C function pointers conform to the `Sendable` protocol. This is safe because they cannot capture values.
-->

与 C 和 Objective-C 的互操作性是 Swift 的一个重要组成部分。由于 Swift 无法强制强制 C 语言 API 行为正确，因此 C 语言代码对于并发来说总是隐含着不安全的要素。然而，我们仍然通过为许多 C 类型提供隐式 `Sendable` 遵循来定义与并发模型的一些基本互动：

* C 的 enum 类型总是遵循 `Sendable` 协议。
* C 的 struct 类型遵循 `Sendable` 协议，如果它们所有的存储属性都遵循 `Sendable`。
* C 的函数指针遵循 `Sendable` 协议。这是很安全的，因为它们无法捕获值。

## 未来工作 / 后续项目

<!--
In addition to the base proposal, there are several follow-on things that could be explored as follow-on proposals.
-->

除了基本提案之外，还有几个后续的东西可以作为后续提案进行探讨。

### Adaptor Types for Legacy Codebases

<!--
**NOTE**: This section is NOT considered part of the proposal — it is included just to illustrate aspects of the design.
-->

**注意**。本节不属于提案的一部分 -- 包含它只是为了说明设计的各个方面。

<!--
The proposal above provides good support for composition and Swift types that are updated to support concurrency.  Further, Swift’s support for retroactive conformance of protocols makes it possible for users to work with codebases that haven’t been updated yet.
-->

上面的提案为组合和 Swift 类型提供了良好的支持，这些类型将被更新以支持并发。此外，Swift 对跳过协议遵循的支持，让用户可以使用尚未更新的遗留代码库。

<!--
However, there is an additional important aspect of compatibility with existing frameworks that is important to confront: frameworks are sometimes designed around dense graphs of mutable objects with ad hoc structures.  While it would be nice to “rewrite the world” eventually, practical Swift programmers will need support to “get things done” in the meantime.  By analogy, when Swift first came out, most Objective-C frameworks were not audited for nullability.  We introduced “`ImplicitlyUnwrappedOptional`” to handle the transition period, which gracefully faded from use over the years.
-->

然而，在与现有框架的兼容性方面，还有一个重要的问题需要面对：框架有时是围绕着具有特殊结构的可变对象密集图设计的。虽然最终能"重写整个世界"是件好事，但实际工作中 Swift 程序员需要得到支持，以便在这期间"将工作完成"。

举个例子，当 Swift 刚出来的时候，大多数 Objective-C 框架都没有对 nullability 进行审核。我们引入了 "`ImplicitlyUnwrappedOptional`" 来处理过渡期的问题，随着时间的推移，它优雅地淡出了使用范围。

<!--
To illustrate how we can do this with Swift concurrency, consider a pattern that is common in Objective-C frameworks: passing an object graph across threads by “transferring” the reference across threads — this is useful but not memory safe!  Programmers will want to be able to express these things as part of their actor APIs within their apps.
-->

为了说明我们如何在 Swift Concurrency 中做到这一点，请考虑 Objective-C 框架中常见的一种模式：通过跨线程"转移"引用来传递一个对象图 -- 这很有用，但不符合内存安全！程序员会希望能够在他们的应用程序中把这些东西作为 actor API 的一部分来表达。

<!--
This can be achieved by the introduction of a generic helper struct:
-->

这可以通过引入一个通用的 helper struct 来实现：

```swift
@propertyWrapper
struct UnsafeTransfer<Wrapped> : @unchecked Sendable {
  var wrappedValue: Wrapped
  init(wrappedValue: Wrapped) {
    self.wrappedValue = wrappedValue
  }
}
```

<!--
For example, `NSMutableDictionary` isn’t safe to pass across concurrency domains, so it isn’t safe to conform to `Sendable`.  The struct above allows you (as an app programmer) to write an actor API in your application like this:
-->

例如，`NSMutableDictionary` 在跨并发域传递时并不安全，所以它没办法安全得遵循 `Sendable`。上面的 struct 允许你（作为应用程序的程序员）像这样写一个 actor 的 API：

```swift
actor MyAppActor {
  // The caller *promises* that it won't use the transferred object.
  public func doStuff(dict: UnsafeTransfer<NSMutableDictionary>) async
}
```

<!--
While this isn’t particularly pretty, it is effective at getting things done on the caller side when you need to work with unaudited and unsafe code.  This can also be sugared into a parameter attribute using the recently proposed [extension to property wrappers for arguments](https://forums.swift.org/t/pitch-2-extend-property-wrappers-to-function-and-closure-parameters/40959), allowing a prettier declaration and caller-side syntax:
-->

虽然这不是特别优雅，但当你需要处理未经审计和不安全的代码时，它能有效地在调用者一方完成工作。这也可以使用最近提出的[将 propertyWrapper 拓展到函数参数](https://forums.swift.org/t/pitch-2-extend-property-wrappers-to-function-and-closure-parameters/40959)，变成一个参数属性，允许一种更优雅的声明和调用方语法：

```swift
actor MyAppActor {
  // The caller *promises* that it won't use the transferred object.
  public func doStuff(@UnsafeTransfer dict: NSMutableDictionary) async
}
```

### Objective-C 框架支持

<!--
**NOTE**: This section is NOT considered part of the proposal — it is included just to illustrate aspects of the design.
-->

**注意**。本节不属于是提案的一部分 - 它只是为了说明设计的各个方面。

<!--
Objective-C has established patterns that would make sense to pull into this framework en-masse, e.g. the [`NSCopying` protocol](https://developer.apple.com/documentation/foundation/nscopying) is one important and widely adopted protocol that should be onboarded into this framework.
-->

Objective-C 已经建立了一些模式，可以合理地融入到这个框架里，例如，[`NSCopying` 协议](https://developer.apple.com/documentation/foundation/nscopying)是一个重要的、被广泛采用的协议，应该被纳入这个框架。

<!--
General consensus is that it is important to make copies explicit in the model, so we can implement an `NSCopied` helper like so:
-->

一般的共识是，在模型中明确复制是很重要的，所以我们可以像这样实现一个 `NSCopied` helper：

```swift
@propertyWrapper
struct NSCopied<Wrapped: NSCopying>: @unchecked Sendable {
  let wrappedValue: Wrapped

  init(wrappedValue: Wrapped) {
    self.wrappedValue = wrappedValue.copy() as! Wrapped
  }
}
```

<!--
This would allow individual arguments and results of actor methods to opt-into a copy like this:
-->

这将允许 actor 方法的个别参数和结果选择使用一个单独的副本：

```swift
actor MyAppActor {
  // The string is implicitly copied each time you invoke this.
  public func lookup(@NSCopied name: NSString) -> Int async
}
```

<!--
One random note: the Objective-C static type system is not very helpful to us with immutability here: statically typed `NSString`’s may actually be dynamically `NSMutableString`’s due to their subclass relationships.  Because of this, it isn’t safe to assume that values of `NSString` type are dynamically immutable — they should be implemented to invoke the `copy()` method.
-->

一个粗略的解释：Objective-C 的静态类型系统在这里对我们的 immutability 帮助不大：静态类型的 `NSString` 由于可以被继承，所以实际上可能是动态的 `NSMutableString`。正因为如此，我们无法假设 `NSString` 类型的值是动态不可变的 -- 它们应该在实现里调用 `copy()` 方法。

### 和 actor self 与 `@Sendable` 闭包的交互

<!--
Actors are a proposal that is conceptually layered on top of this one, but it is important to be aware of the actor design to make sure that this proposal addresses its needs.  As described above, actor method sends across concurrency boundaries naturally require that arguments and results conform to `Sendable`, and thus implicitly require that closures passed across such boundaries are `@Sendable`.
-->

Actor 是基于这个提案之上提出的，但了解 actor 的设计也很重，以确保本提案能满足其需求。如上所述，actor 方法跨越并发边界的发送，要求参数和结果遵循 `Sendable`，因此隐含着一个要求，跨越这种边界传递的闭包必须是 `@Sendable` 的。

<!--
One additional detail that needs to be addressed is “when is something a cross actor call?”.  For example, we would like these calls to be synchronous and not require an await:
-->

还有一个需要解决的细节是"什么时候算是跨 actor 的调用？"。例如，我们希望这些调用是同步的，不需要 await：

```swift
extension SomeActor {
  public func oneSyncFunction(x: Int) {... }
  public func otherSyncFunction() {
    // No await needed: stays in concurrency domain of self actor.
    self.oneSyncFunction(x: 42)
    oneSyncFunction(x: 7)    // Implicit self is fine.
  }
}
```

<!--
However, we also need to consider the case when ‘self’ is captured into a closure within an actor method.  For example:
-->

然而，我们也需要考虑当 `self` 被捕获到 actor 方法中的闭包时的情况。比如说：

```swift
extension SomeActor {
  public func thing(arr: [Int]) {
    // This should obviously be allowed!
    arr.forEach { self.oneSyncFunction(x: $0) }

    // Error: await required because it hops concurrency domains.
    arr.parallelMap { self.oneSyncFunction(x: $0) }

    // Is this ok?
    someHigherOrderFunction {
      self.oneSyncFunction(x: 7)  // ok or not?
    }
  }
}
```

<!--
We need the compiler to know whether there is a possible concurrency domain hop or not — if so, an await is required.  Fortunately, this works out through straight-forward composition of the basic type system rules above: It is perfectly safe to use actor `self` in a non-`@Sendable` closure in an actor method, but using it in a `@Sendable` closure is treated as being from a different concurrency domain, and thus requires an `await`.
-->

我们需要编译器知道是否有一个可能的并发域跳转 -- 如果有，就需要一个 await。幸运的是，这可以通过上述基本类型系统规则的直接组合来实现。在 actor 方法的非 `@Sendable` 闭包中使用 actor `self` 是完全安全的，但是在 `@Sendable` 闭包中使用它将被视为来自不同的并发域，因此需要一个 `await`。

### Marker 协议作为一个自定义注解

<!--
The marker protocol `Sendable` and the function attribute `@Sendable` are intentionally given the same name. There is a potential future direction here where `@Sendable` could move from a special attribute recognized by the compiler (as in this proposal), to having marker protocols like `Sendable` be custom attributes like [property wrappers](https://github.com/apple/swift-evolution/blob/main/proposals/0258-property-wrappers.md) and [result builders](https://github.com/apple/swift-evolution/blob/main/proposals/0289-result-builders.md). Such a change would have very little effect on existing code that uses `@Sendable` so long as users don't declare their own `Sendable` type that shadows the one from the standard library. However, it would make `@Sendable` less special and allow other marker protocols to be used similarly.
-->

marker 协议 `Sendable` 和函数注解 `@Sendable` 被故意赋予相同的名字。这里有一个潜在的未来方向，即 `@Sendable` 可以从一个被编译器识别的特殊注解（如这个提议），类似 `Sendable` 这样使用一个通用的 marker 协议机制，成为自定义属性，如 [propertyWrapper](https://github.com/apple/swift-evolution/blob/main/proposals/0258-property-wrappers.md) 和 [resultBuilder](https://github.com/apple/swift-evolution/blob/main/proposals/0289-result-builders.md)。这样的改变对使用 `@Sendable` 现有的代码影响很小，只要用户不声明他们自己的 `Sendable` 类型，不与标准库中的类型同名。然而，它将使 `@Sendable` 不再特殊，并允许其他 marker 协议以类似的方式使用。

## 代码兼容性

<!--
This is almost completely source compatible with existing code bases. The introduction of the `Sendable` marker protocol  and `@Sendable` functions are additive features that have no impact when not used and therefore do not affect existing code.

There are a few new restrictions that could cause source breakage in exotic cases:

*   The change to keypath literals subscripts will break exotic keypaths that are indexed with non-standard types.
*   `Error` and `CodingKey` inherit from `Sendable` and thus require that custom errors and keys conform to `Sendable`.

Because of these changes, the new restrictions will only be enforced in Swift 6 mode, but will be warnings for Swift 5 and earlier.
-->

这几乎与现有的代码库完全代码兼容。引入 `Sendable` marker 协议和 `@Sendable` 函数注解是附加功能，不使用时没有影响，因此不会影响现有代码。

但这里有一些新的限制，在特殊情况下可能会导致代码兼容性破坏：

* 对 keypath 字面量下标的改变将破坏用非标准类型索引的外部 keypath。
* `Error` 和 `CodingKey` 将添加 `Sendable` 的继承，因此要求自定义 Error 和 CodingKey 符合 `Sendable`。

由于这些修改，新的限制将只在 Swift 6 模式下执行，但对于 Swift 5 和更早的版本将是警告。

## 对 API resilience 的影响

<!--
This proposal has no effect on API resilience!
-->

这项建议对 API 的弹性没有任何影响!

## 其它备选方案

<!--
There are several alternatives that make sense to discuss w.r.t. this proposal.  Here we capture some of the bigger ones.
-->

在讨论这个提案时，有几个备选方案也是很有意义的。在这里，我们尝试讨论一些较大的问题。

### 奇异的类型系统功能

<!--
The [Swift Concurrency Roadmap](https://forums.swift.org/t/swift-concurrency-roadmap/41611) mentions that a future iteration of the feature set could introduce new type system features like “`mutableIfUnique`” classes, and it is easy to imagine that move semantics and unique ownership could get introduced into Swift someday.
-->

[Swift Concurrency Roadmap](https://forums.swift.org/t/swift-concurrency-roadmap/41611) 提到，未来的功能集迭代可能会引入新的类型系统特性，如 "`mutableIfUnique`" 类，而且很容易想象，move 语义和唯一所有权有一天会被引入 Swift。

<!--
While it is difficult to understand the detailed interaction without knowing the full specification of future proposals, we believe that the checking machinery that enforces `Sendable` checking is simple and composable.  It should work with any types that are safe to pass across concurrency boundaries.
-->

虽然在不了解未来提案完整规范的情况下，很难理解详细的交互逻辑，但我们相信执行 `Sendable` 检查的检查机制是简单和可组合的。它应该适用于任何可以安全跨越并发边界的类型。

### 支持一种显式的 copy hook

<!--
The [first revision of this proposal](https://docs.google.com/document/d/1OMHZKWq2dego5mXQtWt1fm-yMca2qeOdCl8YlBG1uwg/edit#) allowed types to define custom behavior when they are sent across concurrency domains, through the implementation of an `unsafeSend` protocol requirement.  This increased the complexity of the proposal, admitted undesired functionality (explicitly implemented copy behavior), made the recursive aggregate case more expensive, and would result in larger code size.
-->

本提案的[第一次修订](https://docs.google.com/document/d/1OMHZKWq2dego5mXQtWt1fm-yMca2qeOdCl8YlBG1uwg/edit#)允许类型在跨并发域发送时自定义行为，通过实现 `unsafeSend` 协议要求。这增加了提案的复杂性，添加了不必要的功能（明确实现的复制行为），使递归聚合的情况消耗更多性能，并且会导致更大的代码二进制文件。

## 总结

<!--
This proposal defines a very simple approach for defining types that are safe to transfer across concurrency domains.  It requires minimal compiler/language support that is consistent with existing Swift features, is extensible by users, works with legacy code bases, and provides a simple model that we can feel good about even 20 years from now.
-->

这项提案引入了一种非常简单的方式，用于定义可以安全地跨并发域传输的类型。它需要的编译器/语言支持很少，与现有的 Swift 功能一致，可由用户扩展，与传统的代码库一起使用，并提供了一个简单的模型，即使在 20 年后我们也会觉得很棒。

<!--
Because the feature is mostly a library feature that builds on existing language support, it is easy to define wrapper types that extend it for domain specific concerns (along the lines of the `NSCopied` example above), and retroactive conformance makes it easy for users to work with older libraries that haven’t been updated to know about the Swift Concurrency model yet.
-->

因为该功能主要是建立在现有语言支持基础上的库功能，所以很容易定义包装类型，为特定领域的关注点进行扩展（按照上面 `NSCopied` 的例子），跳过遵循检查使用户很容易与尚未更新以了解 Swift 并发模型的旧库合作。

## 修订历史

* Changes from the second review:
  * Renamed `@sendable` to `@Sendable`, per review feedback and Core Team decision.
  * Add a future direction on marker protocols as custom attributes.
  * Removed "Swift Concurrency 1.0" and "2.0" discussion in Alternatives Considered.
* Changes from the first review
  * Renamed `ConcurrentValue` to `Sendable` and `@concurrent` to `@sendable`.
  * Replaced `UnsafeConcurrentValue` with `@unchecked Sendable` conformances.
  * Add implicit conformance to `Sendable` for non-public, non-frozen `struct` and `enum` types.