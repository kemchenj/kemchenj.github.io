---
title: "ã€è¯‘ã€‘SE-0306 Actors"
date: 2021-04-25
---

* Proposal: [SE-0306](0306-actors.md)
* Authors: [John McCall](https://github.com/rjmccall), [Doug Gregor](https://github.com/DougGregor), [Konrad Malawski](https://github.com/ktoso), [Chris Lattner](https://github.com/lattner)
* Review Manager: [Joe Groff](https://github.com/jckarter)
* Status: **Implemented (Swift 5.5)**
* Decision Notes: [Acceptance](https://forums.swift.org/t/accepted-with-modification-se-0306-actors/47662), [First Review](https://forums.swift.org/t/se-0306-actors/45734), [Second Review](https://forums.swift.org/t/se-0306-second-review-actors/47291)
* Implementation: Partially available in [recent `main` snapshots](https://swift.org/download/#snapshots) behind the flag `-Xfrontend -enable-experimental-concurrency`

<!--
## Table of Contents

* [Introduction](#introduction)
* [Proposed solution](#proposed-solution)
   * [Actors](#actors-1)
   * [Actor isolation](#actor-isolation)
   * [Cross-actor references and Sendable types](#cross-actor-references-and-sendable-types)
   * [Closures](#closures)
   * [Actor reentrancy](#actor-reentrancy)
      * ["Interleaving" execution with reentrant actors](#interleaving-execution-with-reentrant-actors)
      * [Deadlocks with non-reentrant actors](#deadlocks-with-non-reentrant-actors)
      * [Unnecessary blocking with non-reentrant actors](#unnecessary-blocking-with-non-reentrant-actors)
      * [Existing practice](#existing-practice)
      * [Reentrancy Summary](#reentrancy-summary)
   * [Protocol conformances](#protocol-conformances)
* [Detailed design](#detailed-design)
   * [Actors](#actors-2)
   * [Actor isolation checking](#actor-isolation-checking)
      * [References and actor isolation](#references-and-actor-isolation)
      * [Protocol conformance](#protocol-conformance)
   * [Partial applications](#partial-applications)
   * [Key paths](#key-paths)
   * [inout parameters](#inout-parameters)
   * [Actor interoperability with Objective-C](#actor-interoperability-with-objective-c)
* [Source compatibility](#source-compatibility)
* [Effect on ABI stability](#effect-on-abi-stability)
* [Effect on API resilience](#effect-on-api-resilience)
* [Future Directions](#future-directions)
   * [Non-reentrancy](#non-reentrancy)
   * [Task-chain reentrancy](#task-chain-reentrancy)
* [Alternatives considered](#alternatives-considered) 
   * [Actor inheritance](#actor-inheritance)
   * [Cross-actor lets](#cross-actor-lets)
* [Revision history](#revision-history)
-->

## Introduction

<!--
The Swift concurrency model intends to provide a safe programming model that statically detects [data races](https://en.wikipedia.org/wiki/Race_condition#Data_race) and other common concurrency bugs. The [Structured Concurrency][sc] proposal introduces a way to define concurrent tasks and provides data-race safety for functions and closures. This model is suitable for a number of common design patterns, including things like parallel maps and concurrent callback patterns, but is limited to working with state that is captured by closures.
-->

Swift å¹¶å‘æ¨¡å‹æ‰“ç®—æä¾›ä¸€ä¸ªå®‰å…¨çš„ç¼–ç¨‹æ¨¡å‹ï¼Œé™æ€åœ°æ£€æµ‹ [data-races](https://en.wikipedia.org/wiki/Race_condition#Data_race)å’Œå…¶ä»–å¸¸è§çš„å¹¶å‘é”™è¯¯ã€‚[ç»“æ„åŒ–å¹¶å‘][sc]ææ¡ˆå¼•å…¥äº†ä¸€ç§å®šä¹‰å¹¶å‘ä»»åŠ¡çš„æ–¹æ³•ï¼Œå¹¶ä¸ºå‡½æ•°å’Œé—­åŒ…æä¾›äº†å®‰å…¨çš„ data-raceã€‚è¿™ä¸ªæ¨¡å‹é€‚ç”¨äºè®¸å¤šå¸¸è§çš„è®¾è®¡æ¨¡å¼ï¼ŒåŒ…æ‹¬åƒ parallel maps å’Œå¹¶å‘å›è°ƒæ¨¡å¼ï¼Œä½†åªé™äºå¤„ç†ç”±é—­åŒ…æ•è·çš„çŠ¶æ€ã€‚

<!--
Swift includes classes, which provide a mechanism for declaring mutable state that is shared across the program. Classes, however, are notoriously difficult to correctly use within concurrent programs, requiring error-prone manual synchronization to avoid data races. We want to provide the ability to use shared mutable state while still providing static detection of data races and other common concurrency bugs.
-->

Swift åŒ…å«äº† classï¼Œå®ƒæä¾›äº†ä¸€ç§æœºåˆ¶æ¥å£°æ˜æ•´ä¸ªç¨‹åºä¸­å…±äº«çš„mutableçŠ¶æ€ã€‚ç„¶è€Œï¼Œclass åœ¨å¹¶å‘ç¨‹åºä¸­éš¾ä»¥æ­£ç¡®ä½¿ç”¨ï¼Œéœ€è¦æ‰‹åŠ¨åŒæ­¥æ¥é¿å…æ•°æ®ç«èµ›ï¼Œå¾ˆå®¹æ˜“å‡ºé”™ã€‚æˆ‘ä»¬å¸Œæœ›æä¾›è¿™ä¹ˆä¸€ç§åŠŸèƒ½ï¼Œåœ¨ä½¿ç”¨å…±äº«çš„mutableçŠ¶æ€çš„åŒæ—¶ï¼Œä»ç„¶æä¾›å¯¹ data race å’Œå…¶ä»–å¸¸è§å¹¶å‘é”™è¯¯çš„é™æ€æ£€æµ‹ã€‚

<!--
The [actor model](https://en.wikipedia.org/wiki/Actor_model) defines entities called *actors* that are perfect for this task. Actors allow you as a programmer to declare that a bag of state is held within a concurrency domain and then define multiple operations that act upon it. Each actor protects its own data through *data isolation*, ensuring that only a single thread will access that data at a given time, even when many clients are concurrently making requests of the actor. As part of the Swift Concurrency Model, actors provide the same race and memory safety properties as structured concurrency, but provide the familiar abstraction and reuse features that other explicitly declared types in Swift enjoy.
-->

[Actor æ¨¡å‹](https://en.wikipedia.org/wiki/Actor_model)å®šä¹‰äº†ç§°ä¸º *actors* çš„å®ä½“ï¼Œè¿™äº›å®ä½“éå¸¸é€‚åˆè¿™é¡¹ä»»åŠ¡ã€‚Actor å…è®¸ä½ ï¼Œä½œä¸ºä¸€ä¸ªç¨‹åºå‘˜ï¼Œå£°æ˜ä¸€ç³»åˆ—çš„çŠ¶æ€ï¼Œè¿™äº›çŠ¶æ€ç”±ä¸€ä¸ª concurrency domain æŒæœ‰ï¼Œå¹¶ä¸”å¯ä»¥å®šä¹‰å¤šä¸ªå¯¹å…¶çš„æ“ä½œã€‚æ¯ä¸ª actor é€šè¿‡ *data isolation* æ¥ä¿æŠ¤è‡ªå·±çš„æ•°æ®ï¼Œç¡®ä¿åœ¨æŸä¸ªæ—¶é—´åªæœ‰ä¸€ä¸ªçº¿ç¨‹è®¿é—®å®ƒçš„æ•°æ®ï¼Œå³ä½¿è®¸å¤šç”¨æˆ·åŒæ—¶å‘ actor å‘å‡ºè¯·æ±‚ã€‚ä½œä¸º Swift å¹¶å‘æ¨¡å‹çš„ä¸€éƒ¨åˆ†ï¼Œactor æä¾›äº†ä¸ç»“æ„åŒ–å¹¶å‘ç›¸åŒçš„ race å’Œå†…å­˜å®‰å…¨å±æ€§ï¼Œä½†ä¹Ÿæä¾›äº† Swift ä¸­å…¶ä»–æ˜¾å¼å£°æ˜çš„ç±»å‹æ‰€äº«æœ‰çš„ç†Ÿæ‚‰çš„æŠ½è±¡å’Œå¤ç”¨çš„ç‰¹æ€§ã€‚

<!--more-->

Swift-evolution threads:
  [Pitch #1](https://forums.swift.org/t/concurrency-actors-actor-isolation/41613),
  [Pitch #2](https://forums.swift.org/t/pitch-2-actors/44094),
  [Pitch #3](https://forums.swift.org/t/pitch-3-actors/44470),
  [Pitch #4](https://forums.swift.org/t/pitch-4-actors/45215),
  [Pitch #5](https://forums.swift.org/t/pitch-4-actors/45215/36),
  [Pitch #6](https://forums.swift.org/t/pitch-6-actors/45519),
  [Review #1](https://forums.swift.org/t/se-0306-actors/45734)

## Proposed solution

### Actors

<!--
This proposal introduces *actors* into Swift. An actor is a reference type that protects access to its mutable state, and is introduced with the keyword `actor`:
-->

è¿™é¡¹ææ¡ˆå°†å¼•å…¥ *actors*ã€‚Actor æ˜¯ä¸€ç§å¼•ç”¨ç±»å‹ï¼Œå¯ä»¥ä¿æŠ¤å®ƒçš„ mutable state çš„è®¿é—®ï¼Œé€šè¿‡å…³é”®å­— `actor` å¼•å…¥ï¼š

```swift
actor BankAccount {
  let accountNumber: Int
  var balance: Double

  init(accountNumber: Int, initialDeposit: Double) {
    self.accountNumber = accountNumber
    self.balance = initialDeposit
  }
}
```

<!--
Like other Swift types, actors can have initializers, methods, properties, and subscripts. They can be extended and conform to protocols, be generic, and be used with generics.
-->

å°±åƒå…¶å®ƒçš„ Swift ç±»å‹ï¼Œ`actor` å¯ä»¥æœ‰æ„é€ å™¨ã€æ–¹æ³•ã€å±æ€§å’Œä¸‹æ ‡ã€‚å®ƒä»¬å¯ä»¥è¢«æ‰©å±•å¹¶éµå¾ªåè®®ï¼Œå¯ä»¥æ˜¯æ³›å‹ï¼Œä¹Ÿå¯ä»¥ä¸æ³›å‹ä¸€èµ·ä½¿ç”¨ã€‚

<!--
The primary difference is that actors protect their state from data races. This is enforced statically by the Swift compiler through a set of limitations on the way in which actors and their instance members can be used, collectively called *actor isolation*.   
-->

æœ€ä¸»è¦çš„åŒºåˆ«æ˜¯ï¼Œactor ä¿æŠ¤å…¶çŠ¶æ€ä¸å— data-race å½±å“ã€‚è¿™ä¸€ç‚¹ä¼šç”± Swift ç¼–è¯‘å™¨é™æ€åœ°å¼ºåˆ¶æ‰§è¡Œï¼Œé€šè¿‡å¯¹ actor ä»¥åŠå®ä¾‹æˆå‘˜çš„ä½¿ç”¨æ–¹å¼è¿›è¡Œä¸€ç³»åˆ—çš„é™åˆ¶ï¼Œè¿™äº›é™åˆ¶ç»Ÿç§°ä¸º*actor isolation*ã€‚  

### Actor isolation

<!--
Actor isolation is how actors protect their state. For actors, the primary mechanism for this protection is by only allowing their stored instance properties to be accessed directly on `self`. For example, here is a method that attempts to transfer money from one account to another:
-->

Actor isolation æ˜¯ actor ä¿æŠ¤å…¶çŠ¶æ€çš„æ–¹å¼ã€‚å¯¹äº actor æ¥è¯´ï¼Œè¿™ç§ä¿æŠ¤çš„ä¸»è¦æœºåˆ¶æ˜¯åªå…è®¸å­˜å‚¨çš„å®ä¾‹å±æ€§é€šè¿‡ `self` è®¿é—®ã€‚ä¾‹å¦‚ï¼Œè¿™é‡Œæœ‰ä¸€ä¸ªæ–¹æ³•ï¼Œè¯•å›¾å°†é’±ä»ä¸€ä¸ªè´¦æˆ·è½¬åˆ°å¦ä¸€ä¸ªè´¦æˆ·ï¼š

```swift
extension BankAccount {
  enum BankError: Error {
    case insufficientFunds
  }
  
  func transfer(amount: Double, to other: BankAccount) throws {
    if amount > balance {
      throw BankError.insufficientFunds
    }

    balance = balance - amount
    other.balance = other.balance + amount  // error: actor-isolated property 'balance' can only be referenced on 'self'
  }
}
```

<!--
If `BankAccount` were a class, the `transfer(amount:to:)` method would be well-formed, but would be subject to data races in concurrent code without an external locking mechanism. 
-->

å¦‚æœ `BankAccount` æ˜¯ä¸€ä¸ª classï¼Œ`transfer(amount:to:)` æ–¹æ³•å°±æ˜¯å®šä¹‰æ­£ç¡®çš„ï¼Œä½†åœ¨æ²¡æœ‰å¤–éƒ¨åŠ é”çš„å¹¶å‘ä»£ç ä¸­ä¼šå‡ºç°æ•°æ®ç«äº‰ã€‚

<!--
With actors, the attempt to reference `other.balance` triggers a compiler error, because `balance` may only be referenced on `self`. The error message notes that `balance` is *actor-isolated*, meaning that it can only be accessed directly from within the specific actor it is tied to or "isolated by". In this case, it's the instance of `BankAccount` referenced by `self`. All declarations on an instance of an actor, including stored and computed instance properties (like `balance`), instance methods (like `transfer(amount:to:)`), and instance subscripts, are all actor-isolated by default. Actor-isolated declarations can freely refer to other actor-isolated declarations on the same actor instance (on `self`). Any declaration that is not actor-isolated is *non-isolated* and cannot synchronously access any actor-isolated declaration.
-->

ä½¿ç”¨ actor æ—¶ï¼Œè¯•å›¾è®¿é—® `other.balance` ä¼šå¼•å‘ç¼–è¯‘é”™è¯¯ï¼Œå› ä¸º `balance` åªèƒ½é€šè¿‡ `self` è®¿é—®ã€‚é”™è¯¯ä¿¡æ¯æŒ‡å‡º `balance` æ˜¯éš”ç¦»åœ¨ actor é‡Œçš„ï¼Œæ„å‘³ç€å®ƒåªèƒ½ä»å®ƒè¢«ç»‘å®šæˆ–"éš”ç¦»"çš„ç‰¹å®š actor ä¸­ç›´æ¥è®¿é—®ã€‚åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œå®ƒæ˜¯ç”± `self` å¼•ç”¨çš„ `BankAccount` çš„å®ä¾‹ã€‚æ‰€æœ‰å…³äº actor å®ä¾‹çš„å£°æ˜ï¼ŒåŒ…æ‹¬å­˜å‚¨å’Œè®¡ç®—çš„å®ä¾‹å±æ€§ï¼ˆå¦‚ `balance`ï¼‰ã€å®ä¾‹æ–¹æ³•ï¼ˆå¦‚`transfer(amount:to:)`ï¼‰å’Œå®ä¾‹ä¸‹æ ‡ï¼Œé»˜è®¤éƒ½æ˜¯ actor-isolated çš„ã€‚actor-isolated çš„å£°æ˜å¯ä»¥è‡ªç”±åœ°å¼•ç”¨åŒä¸€ actor å®ä¾‹ä¸Šçš„å…¶ä»– actor isolated çš„å£°æ˜ï¼ˆé€šè¿‡ `self`ï¼‰ã€‚ä»»ä½•æ²¡æœ‰ actor isolated çš„å£°æ˜éƒ½æ˜¯ *non-isolated* çš„ï¼Œä¸èƒ½åŒæ­¥è®¿é—®ä»»ä½• actor-isolated çš„å£°æ˜ã€‚

<!--
A reference to an actor-isolated declaration from outside that actor is called a *cross-actor reference*. Such references are permissible only when performed asynchronously. Such asynchronous accesses are turned into "messages" requesting that the actor execute the corresponding task when it can safely do so. These messages are stored in the actor's "mailbox", and the caller initiating the asynchronous function invocation may be suspended until the actor is able to process the corresponding message in its mailbox. An actor processes the messages in its mailbox sequentially, so that a given actor will never have two concurrently-executing tasks running actor-isolated code. This ensures that there are no data races on actor-isolated state, because there is no concurrency in any code that can access actor-isolated state. For example, if we wanted to make a deposit to a given bank account `account`, we could make a call to a method `deposit(amount:)` on another actor, and that call would become a message placed in the actor's mailbox and the caller would suspend. When that actor processes messages, it will eventually process the message corresponding to the deposit, executing that call within the actor's isolation domain when no other code is executing in that actor's isolation domain.
-->

ä» actor å¤–éƒ¨å¯¹ä¸€ä¸ª actor isolated çš„å£°æ˜çš„å¼•ç”¨è¢«ç§°ä¸º*è·¨ actor å¼•ç”¨*ã€‚è¿™ç§å¼•ç”¨åªæœ‰åœ¨å¼‚æ­¥æ‰§è¡Œæ—¶æ‰æ˜¯å…è®¸çš„ã€‚è¿™ç§å¼‚æ­¥è®¿é—®è¢«è½¬åŒ–ä¸º"æ¶ˆæ¯"ï¼Œå¹¶ä¸”è¦æ±‚ actor å¯ä»¥å®‰å…¨åœ°æ‰§è¡Œç›¸åº”çš„ä»»åŠ¡ã€‚è¿™äº›æ¶ˆæ¯è¢«å­˜å‚¨åœ¨ actor çš„"é‚®ç®±"ä¸­ï¼Œå¯åŠ¨å¼‚æ­¥å‡½æ•°è°ƒç”¨çš„è°ƒç”¨è€…å¯èƒ½è¢«æš‚åœï¼Œç›´åˆ° actor èƒ½å¤Ÿå¤„ç†å…¶é‚®ç®±ä¸­çš„ç›¸åº”æ¶ˆæ¯ã€‚actor æŒ‰é¡ºåºå¤„ç†å…¶é‚®ç®±ä¸­çš„æ¶ˆæ¯ï¼Œå› æ­¤ï¼Œä¸€ä¸ªç»™å®šçš„ actor å°†æ°¸è¿œä¸ä¼šæœ‰ä¸¤ä¸ªåŒæ—¶æ‰§è¡Œçš„ä»»åŠ¡è¿è¡Œ actor-isolated çš„ä»£ç ã€‚è¿™ç¡®ä¿äº†åœ¨ actor-isolated çš„çŠ¶æ€ä¸ä¼šæœ‰æ•°æ®ç«èµ›ï¼Œå› ä¸ºåœ¨ä»»ä½•å¯ä»¥è®¿é—® actor-isolated çš„çŠ¶æ€çš„ä»£ç éƒ½æ²¡æœ‰å¹¶å‘æ€§ã€‚ä¾‹å¦‚ï¼Œå¦‚æœæˆ‘ä»¬æƒ³ç»™ä¸€ä¸ªç»™å®šçš„é“¶è¡Œè´¦æˆ· `account` å­˜æ¬¾ï¼Œæˆ‘ä»¬å¯ä»¥è°ƒç”¨å¦ä¸€ä¸ª actor ä¸Šçš„æ–¹æ³• `deposit(amount:)`ï¼Œè¿™ä¸ªè°ƒç”¨å°†æˆä¸ºä¸€ä¸ªæ”¾åœ¨è¯¥ actor é‚®ç®±ä¸­çš„æ¶ˆæ¯ï¼Œè°ƒç”¨è€…å°†æš‚åœã€‚å½“è¯¥ actor å¤„ç†æ¶ˆæ¯æ—¶ï¼Œå®ƒæœ€ç»ˆä¼šå¤„ç†ä¸å­˜æ¬¾ç›¸å¯¹åº”çš„æ¶ˆæ¯ï¼Œå½“æ²¡æœ‰å…¶ä»–ä»£ç åœ¨è¯¥ actor çš„éš”ç¦»åŸŸä¸­æ‰§è¡Œæ—¶ï¼Œå°±åœ¨è¯¥ actor çš„éš”ç¦»åŸŸä¸­æ‰§è¡Œè¯¥è°ƒç”¨ã€‚

<!--
> **Implementation note**: At an implementation level, the messages are partial tasks (described by the [Structured Concurrency][sc] proposal) for the asynchronous call, and each actor instance contains its own serial executor (also in the [Structured Concurrency][sc] proposal). The serial executor is responsible for running the partial tasks sequentially. This is conceptually similar to a serial [`DispatchQueue`](https://developer.apple.com/documentation/dispatch/dispatchqueue), but the actual implementation in the actor runtime uses a lighter-weight implementation that takes advantage of Swift's `async` functions.
-->

> **å®ç°è¯´æ˜**ã€‚åœ¨å®ç°å±‚é¢ä¸Šï¼Œæ¶ˆæ¯æ˜¯å¼‚æ­¥è°ƒç”¨çš„ partial taskï¼ˆç”±[ç»“æ„åŒ–å¹¶å‘][sc]ææ¡ˆæè¿°ï¼‰ï¼Œæ¯ä¸ª actor å®ä¾‹åŒ…å«è‡ªå·±çš„ serial executorï¼ˆä¹Ÿåœ¨[ç»“æ„åŒ–å¹¶å‘][sc]ææ¡ˆä¸­ï¼‰ã€‚Serial executor è´Ÿè´£æŒ‰é¡ºåºè¿è¡Œéƒ¨åˆ†ä»»åŠ¡ã€‚è¿™åœ¨æ¦‚å¿µä¸Šç±»ä¼¼äºä¸€ä¸ªä¸²è¡Œçš„ [`DispatchQueue`](https://developer.apple.com/documentation/dispatch/dispatchqueue)ï¼Œä½†åœ¨ actor è¿è¡Œæ—¶çš„å®é™…å®ç°ä¸­ä½¿ç”¨äº†ä¸€ä¸ªæ›´è½»é‡çº§çš„å®ç°ï¼Œåˆ©ç”¨äº† Swift çš„ `async` å‡½æ•°ã€‚

<!--
Compile-time actor-isolation checking determines which references to actor-isolated declarations are cross-actor references, and ensures that such references use one of the two permissible mechanisms described above. This ensures that code outside of the actor does not interfere with the actor's mutable state.
-->

ç¼–è¯‘æ—¶ actor-isolation æ£€æŸ¥ç¡®å®šå“ªäº›å¯¹ actor-isolated å£°æ˜çš„å¼•ç”¨æ˜¯è·¨ actorçš„ å¼•ç”¨ï¼Œå¹¶ç¡®ä¿è¿™ç§å¼•ç”¨ä½¿ç”¨ä¸Šè¿°ä¸¤ç§å…è®¸çš„æœºåˆ¶ä¹‹ä¸€ã€‚è¿™ç¡®ä¿äº† actor ä¹‹å¤–çš„ä»£ç ä¸ä¼šå¹²æ‰° actor çš„ mutable çŠ¶æ€ã€‚

<!--
Based on the above, we can implement a correct version of `transfer(amount:to:)` that is asynchronous:
-->

åŸºäºä¸Šè¿°ï¼Œæˆ‘ä»¬å¯ä»¥å®ç°ä¸€ä¸ªæ­£ç¡®çš„ `transfer(amount:to:)` ç‰ˆæœ¬ï¼Œå®ƒæ˜¯å¼‚æ­¥çš„ï¼š

```swift
extension BankAccount {
  func transfer(amount: Double, to other: BankAccount) async throws {
    assert(amount > 0)

    if amount > balance {
      throw BankError.insufficientFunds
    }

    // Safe: this operation is the only one that has access to the actor's isolated
    // state right now, and there have not been any suspension points between
    // the place where we checked for sufficient funds and here.
    balance = balance - amount
    
    // Safe: the deposit operation is placed in the `other` actor's mailbox; when
    // that actor retrieves the operation from its mailbox to execute it, the
    // other account's balance will get updated.
    await other.deposit(amount: amount)
  }
}
```

<!--
The `deposit(amount:)` operation needs to involve the state of a different actor, so it must be invoked asynchronously. This method could itself be implemented as `async`:
-->

`deposit(amount:)` æ“ä½œéœ€è¦æ¶‰åŠä¸åŒ actor çš„çŠ¶æ€ï¼Œæ‰€ä»¥å¿…é¡»å¼‚æ­¥è°ƒç”¨ã€‚è¿™ä¸ªæ–¹æ³•æœ¬èº«å¯ä»¥è¢«å®ç°ä¸º `async`ï¼š

```swift
extension BankAccount {
  func deposit(amount: Double) async {
    assert(amount >= 0)
    balance = balance + amount
  }
}
```

<!--
However, this method doesn't really need to be `async`: it makes no asynchronous calls (note the lack of `await`). Therefore, it would be better defined as a synchronous function:
-->

ç„¶è€Œï¼Œè¿™ä¸ªæ–¹æ³•å…¶å®å¹¶ä¸éœ€è¦æ˜¯ `async`ï¼šå®ƒæ²¡æœ‰è¿›è¡Œå¼‚æ­¥è°ƒç”¨ï¼ˆæ³¨æ„æ²¡æœ‰ `await`ï¼‰ã€‚å› æ­¤ï¼Œå®ƒæœ€å¥½è¢«å®šä¹‰ä¸ºä¸€ä¸ªåŒæ­¥å‡½æ•°ï¼š

```swift
extension BankAccount {
  func deposit(amount: Double) {
    assert(amount >= 0)
    balance = balance + amount
  }
}
```

<!--
Synchronous actor functions can be called synchronously on the actor's `self`, but cross-actor references to this method require an asynchronous call. The `transfer(amount:to:)` function calls it asynchronously (on `other`), while the following function `passGo` calls it synchronously (on the implicit `self`):
-->

åŒæ­¥çš„ actor å‡½æ•°å¯ä»¥åœ¨ actor çš„ `self` ä¸ŠåŒæ­¥è°ƒç”¨ï¼Œä½†æ˜¯è·¨ actor å¼•ç”¨è¿™ä¸ªæ–¹æ³•éœ€è¦å¼‚æ­¥è°ƒç”¨ã€‚`transfer(amount:to:)` å‡½æ•°å¼‚æ­¥è°ƒç”¨å®ƒï¼ˆåœ¨ `other` ä¸Šï¼‰ï¼Œè€Œä¸‹é¢çš„å‡½æ•° `passGo` åŒæ­¥è°ƒç”¨å®ƒï¼ˆåœ¨éšå¼ `self` ä¸Šï¼‰ã€‚

```swift
extension BankAccount {
  // Pass go and collect $200
  func passGo() {
    self.deposit(amount: 200.0)  // synchronous is okay because `self` is isolated
  }
}
```

<!--
Cross-actor references to an actor property are permitted as an asynchronous call so long as they are read-only accesses:
-->

åªè¦æ˜¯åªè¯»è®¿é—®ï¼Œå…è®¸è·¨ actor å¯¹ actor å±æ€§çš„å¼•ç”¨ä½œä¸ºå¼‚æ­¥è°ƒç”¨ï¼š

```swift
func checkBalance(account: BankAccount) {
  print(await account.balance)   // okay
  await account.balance = 1000.0 // error: cross-actor property mutations are not permitted
}
```

<!--
> **Rationale**: it is possible to support cross-actor property sets. However, cross-actor `inout` operations cannot be reasonably supported because there would be an implicit suspension point between the "get" and the "set" that could introduce what would effectively be race conditions. Moreover, setting properties asynchronously may make it easier to break invariants unintentionally if, e.g., two properties need to be updated at once to maintain an invariant.
-->

> **ç†ç”±**ï¼šæ”¯æŒè·¨ actor çš„å±æ€§é›†æ˜¯å¯èƒ½çš„ã€‚ç„¶è€Œï¼Œä¸èƒ½åˆç†åœ°æ”¯æŒè·¨ actor çš„ `inout` æ“ä½œï¼Œå› ä¸ºåœ¨ `get` å’Œ `set` ä¹‹é—´ä¼šæœ‰ä¸€ä¸ªéšå«çš„æš‚åœç‚¹ï¼Œå¯èƒ½ä¼šå¼•å…¥æœ‰æ•ˆçš„ç«èµ›æ¡ä»¶ã€‚æ­¤å¤–ï¼Œå¼‚æ­¥è®¾ç½®å±æ€§å¯èƒ½ä¼šä½¿å…¶æ›´å®¹æ˜“æ— æ„ä¸­ç ´åä¸å˜æ€§ï¼Œä¾‹å¦‚ï¼Œä¸¤ä¸ªå±æ€§éœ€è¦åŒæ—¶æ›´æ–°ä»¥ä¿æŒä¸å˜æ€§ã€‚

### Cross-actor references and `Sendable` types

<!--
[SE-0302][se302] introduces the `Sendable` protocol. Values of types that conform to the `Sendable` protocol are safe to share across concurrently-executing code. There are various kinds of types that work well this way: value-semantic types like `Int` and `String`, value-semantic collections of such types like `[String]` or `[Int: String]`, immutable classes, classes that perform their own synchronization internally (like a concurrent hash table), and so on.
-->

[SE-0302][se302] ä»‹ç»äº† `Sendable` åè®®ã€‚ç¬¦åˆ `Sendable` åè®®çš„ç±»å‹çš„å€¼å¯ä»¥åœ¨å¹¶å‘æ‰§è¡Œçš„ä»£ç ä¸­å®‰å…¨åœ°å…±äº«ã€‚æœ‰å„ç§å„æ ·çš„ç±»å‹ä»¥è¿™ç§æ–¹å¼å·¥ä½œï¼šåƒ `Int` å’Œ `String` è¿™æ ·çš„å€¼è¯­ä¹‰ç±»å‹ï¼Œåƒ `[String]` æˆ– `[Int: String]` è¿™æ ·çš„å€¼è¯­ä¹‰é›†åˆï¼Œimmutable çš„ classï¼Œå†…éƒ¨æ‰§è¡Œè‡ªå·±åŒæ­¥çš„ç±»ï¼ˆä¾‹å¦‚ ConcurrentHashMapï¼‰ï¼Œç­‰ç­‰ã€‚

<!--
Actors protect their mutable state, so actor instances can be freely shared across concurrently-executing code, and the actor itself will internally maintain synchronization. Therefore, every actor type implicitly conforms to the `Sendable` protocol.
-->

actor ä¿æŠ¤å…¶ mutable çš„çŠ¶æ€ï¼Œæ‰€ä»¥ actor å®ä¾‹å¯ä»¥åœ¨å¹¶å‘æ‰§è¡Œçš„ä»£ç ä¸­è‡ªç”±å…±äº«ï¼Œè€Œä¸” actor  æœ¬èº«å°†åœ¨å†…éƒ¨ä¿æŒåŒæ­¥ã€‚å› æ­¤ï¼Œæ¯ä¸ª actor ç±»å‹éƒ½éšå«åœ°ç¬¦åˆ `Sendable` åè®®ã€‚

All cross-actor references are, necessarily, working with values of types that are being shared across different concurrently-executed code. For example, let's say that our `BankAccount` includes a list of owners, where each owner is modeled by a `Person` class:

æ‰€æœ‰çš„è·¨actorå¼•ç”¨éƒ½å¿…é¡»ä¸åœ¨ä¸åŒçš„å¹¶å‘æ‰§è¡Œçš„ä»£ç ä¸­å…±äº«çš„ç±»å‹çš„å€¼ä¸€èµ·å·¥ä½œã€‚ä¾‹å¦‚ï¼Œå‡è®¾æˆ‘ä»¬çš„ `BankAccount` åŒ…æ‹¬ä¸€ä¸ªæ‰€æœ‰è€…åˆ—è¡¨ï¼Œæ¯ä¸ªæ‰€æœ‰è€…éƒ½ç”±ä¸€ä¸ª `Person` ç±»å»ºæ¨¡ã€‚

```swift
class Person {
  var name: String
  let birthDate: Date
}

actor BankAccount {
  // ...
  var owners: [Person]

  func primaryOwner() -> Person? { return owners.first }
}
```

The `primaryOwner` function can be called asynchronously from another actor, and then the `Person` instance can be modified from anywhere:

`primaryOwner`å‡½æ•°å¯ä»¥ä»å¦ä¸€ä¸ªactorä¸­å¼‚æ­¥è°ƒç”¨ï¼Œç„¶åå¯ä»¥ä»ä»»ä½•åœ°æ–¹ä¿®æ”¹`Person`å®ä¾‹ã€‚

```swift
if let primary = await account.primaryOwner() {
  primary.name = "The Honorable " + primary.name  // problem: concurrent mutation of actor-isolated state
}
```

Even non-mutating access is problematic, because the person's `name` could be modified from within the actor at the same time as the original call is trying to access it. To prevent this potential for concurrent mutation of actor-isolated state, all cross-actor references can only involve types that conform to `Sendable`. For a cross-actor asynchronous call, the argument and result types must conform to `Sendable`. For a cross-actor reference to a property, the property type must conform to `Sendable`. By insisting that all cross-actor references only use `Sendable` types, we can ensure that no references to shared mutable state flow into or out of the actor's isolation domain. The compiler will produce a diagnostic for such issues. For example, the call to `account.primaryOwner()` about would produce an error like the following:

å³ä½¿æ˜¯éçªå˜çš„è®¿é—®ä¹Ÿæ˜¯æœ‰é—®é¢˜çš„ï¼Œå› ä¸ºåœ¨åŸå§‹è°ƒç”¨è¯•å›¾è®¿é—®è¿™ä¸ªäººçš„æ—¶å€™ï¼Œè¿™ä¸ªäººçš„ "åå­— "ä¹Ÿå¯èƒ½ä»actorå†…éƒ¨è¢«ä¿®æ”¹ã€‚ä¸ºäº†é˜²æ­¢è¿™ç§actor-isolatedçŠ¶æ€çš„å¹¶å‘çªå˜çš„å¯èƒ½æ€§ï¼Œæ‰€æœ‰çš„è·¨actorå¼•ç”¨åªèƒ½æ¶‰åŠç¬¦åˆ`Sendable`çš„ç±»å‹ã€‚å¯¹äºä¸€ä¸ªè·¨actorçš„å¼‚æ­¥è°ƒç”¨ï¼Œå‚æ•°å’Œç»“æœç±»å‹å¿…é¡»ç¬¦åˆ`Sendable`ã€‚å¯¹äºä¸€ä¸ªè·¨actorçš„å±æ€§å¼•ç”¨ï¼Œå±æ€§ç±»å‹å¿…é¡»ç¬¦åˆ`Sendable`ã€‚é€šè¿‡åšæŒæ‰€æœ‰çš„è·¨actorå¼•ç”¨åªä½¿ç”¨`Sendable`ç±»å‹ï¼Œæˆ‘ä»¬å¯ä»¥ç¡®ä¿å¯¹å…±äº«mutableçŠ¶æ€çš„å¼•ç”¨ä¸ä¼šæµå…¥æˆ–æµå‡ºactorçš„éš”ç¦»åŸŸã€‚ç¼–è¯‘å™¨ä¼šå¯¹è¿™ç±»é—®é¢˜äº§ç”Ÿè¯Šæ–­ã€‚ä¾‹å¦‚ï¼Œå¯¹`account.primaryOwner()`çš„è°ƒç”¨ä¼šäº§ç”Ÿç±»ä¼¼ä»¥ä¸‹çš„é”™è¯¯ã€‚

```
error: cannot call function returning non-Sendable type 'Person?' across actors
```

Note that the `primaryOwner()` function as defined above can still be used with actor-isolated code. For example, we can define a function to get the name of the primary owner, like this:

è¯·æ³¨æ„ï¼Œä¸Šé¢å®šä¹‰çš„`primaryOwner()`å‡½æ•°ä»ç„¶å¯ä»¥ç”¨äºè¡Œä¸ºè€…éš”ç¦»çš„ä»£ç ã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬å¯ä»¥å®šä¹‰ä¸€ä¸ªå‡½æ•°æ¥è·å–ä¸»è¦æ‰€æœ‰è€…çš„åå­—ï¼Œåƒè¿™æ ·ã€‚

```swift
extension BankAccount {
  func primaryOwnerName() -> String? {
    return primaryOwner()?.name
  }
}
```

The `primaryOwnerName()` function is safe to asynchronously call across actors because `String` (and therefore `String?`) conforms to `Sendable`.

`primaryOwnerName()`å‡½æ•°å¯ä»¥å®‰å…¨åœ°è·¨actorå¼‚æ­¥è°ƒç”¨ï¼Œå› ä¸º`String`ï¼ˆå› æ­¤ä¹ŸåŒ…æ‹¬`String?`ï¼‰ç¬¦åˆ`Sendable`ã€‚

### Closures

The restrictions on cross-actor references only work so long as we can ensure that the code that might execute concurrently with actor-isolated code is considered to be non-isolated. For example, consider a function that schedules report generation at the end of the month:

å¯¹è·¨actorå¼•ç”¨çš„é™åˆ¶åªæœ‰åœ¨æˆ‘ä»¬èƒ½ç¡®ä¿å¯èƒ½ä¸actoréš”ç¦»çš„ä»£ç åŒæ—¶æ‰§è¡Œçš„ä»£ç è¢«è§†ä¸ºééš”ç¦»çš„æƒ…å†µä¸‹æ‰æœ‰æ•ˆã€‚ä¾‹å¦‚ï¼Œè€ƒè™‘ä¸€ä¸ªå°†æŠ¥å‘Šç”Ÿæˆå®‰æ’åœ¨æœˆåº•çš„å‡½æ•°ï¼š

```swift
extension BankAccount {
  func endOfMonth(month: Int, year: Int) {
    // Schedule a task to prepare an end-of-month report.
    detach {
      let transactions = await self.transactions(month: month, year: year)
      let report = Report(accountNumber: self.accountNumber, transactions: transactions)
      await report.email(to: self.accountOwnerEmailAddress)
    }
  }
}
```

A task created with `detach` runs concurrently with all other code. If the closure passed to `detach` were to be actor-isolated, we would introduce a data race on access to the mutable state on `BankAccount`. Actors prevent this data race by specifying that a `@Sendable` closure (described in [`Sendable` and `@Sendable` closures][se302], and used in the definition of `detach` in the [Structured Concurrency][sc] proposal) is always non-isolated. Therefore, it is required to asynchronously access any actor-isolated declarations.

ç”¨ `detach` åˆ›å»ºçš„ä»»åŠ¡ä¸æ‰€æœ‰å…¶ä»–ä»£ç åŒæ—¶è¿è¡Œã€‚å¦‚æœä¼ é€’ç»™`detach`çš„é—­åŒ…è¢«è¡Œä¸ºè€…éš”ç¦»ï¼Œæˆ‘ä»¬å°†åœ¨è®¿é—®`BankAccount`çš„mutableçŠ¶æ€æ—¶å¼•å…¥æ•°æ®ç«èµ›ã€‚actoré€šè¿‡æŒ‡å®š`@Sendable`é—­åŒ…ï¼ˆåœ¨[`Sendable`å’Œ`@Sendable`é—­åŒ…][se302]ä¸­æè¿°ï¼Œå¹¶åœ¨[ç»“æ„åŒ–å¹¶å‘][sc]ææ¡ˆä¸­ç”¨äº`detach`çš„å®šä¹‰ï¼‰æ€»æ˜¯éå­¤ç«‹çš„æ¥é˜²æ­¢è¿™ç§æ•°æ®ç«èµ›ã€‚å› æ­¤ï¼Œå®ƒéœ€è¦å¼‚æ­¥è®¿é—®ä»»ä½•actor-isolatedçš„å£°æ˜ã€‚

A closure that is not `@Sendable` cannot escape the concurrency domain in which it was formed. Therefore, such a closure will be actor-isolated if it is formed within an actor-isolated context. This is useful, for example, when applying sequence algorithms like `forEach` where the provided closure will be called serially:

ä¸€ä¸ªä¸æ˜¯"@Sendable "çš„é—­åŒ…ä¸èƒ½è„±ç¦»å®ƒæ‰€å½¢æˆçš„å¹¶å‘åŸŸã€‚å› æ­¤ï¼Œå¦‚æœè¿™æ ·çš„é—­åŒ…æ˜¯åœ¨ä¸€ä¸ªè¡Œä¸ºè€…éš”ç¦»çš„ä¸Šä¸‹æ–‡ä¸­å½¢æˆçš„ï¼Œé‚£ä¹ˆå®ƒå°†æ˜¯è¡Œä¸ºè€…éš”ç¦»çš„ã€‚è¿™å¾ˆæœ‰ç”¨ï¼Œä¾‹å¦‚ï¼Œå½“åº”ç”¨åƒ`forEach`è¿™æ ·çš„åºåˆ—ç®—æ³•æ—¶ï¼Œæ‰€æä¾›çš„é—­åŒ…å°†è¢«è¿ç»­è°ƒç”¨ã€‚

```swift
extension BankAccount {
  func close(distributingTo accounts: [BankAccount]) async {
    let transferAmount = balance / accounts.count

    accounts.forEach { account in                        // okay, closure is actor-isolated to `self`
      balance = balance - transferAmount            
      await account.deposit(amount: transferAmount)
    }
    
    await thief.deposit(amount: balance)
  }
}
```

A closure formed within an actor-isolated context is actor-isolated if it is non-`@Sendable`, and non-isolated if it is `@Sendable`. For the examples above:

åœ¨ä¸€ä¸ªè¡Œä¸ºè€…éš”ç¦»çš„ä¸Šä¸‹æ–‡ä¸­å½¢æˆçš„é—­åŒ…ï¼Œå¦‚æœå®ƒæ˜¯é`@Sendable'ï¼Œåˆ™æ˜¯è¡Œä¸ºè€…éš”ç¦»çš„ï¼Œå¦‚æœå®ƒæ˜¯`@Sendable'ï¼Œåˆ™æ˜¯ééš”ç¦»çš„ã€‚å¯¹äºä¸Šé¢çš„ä¾‹å­ã€‚

* The closure passed to `detach` is non-isolated because that function requires a `@Sendable` function to be passed to it.
* The closure passed to `forEach` is actor-isolated to `self` because it takes a non-`@Sendable` function.

* ä¼ é€’ç»™`detach`çš„é—­åŒ…æ˜¯ééš”ç¦»çš„ï¼Œå› ä¸ºè¯¥å‡½æ•°éœ€è¦ä¸€ä¸ª`@Sendable`å‡½æ•°è¢«ä¼ é€’ç»™å®ƒã€‚
* ä¼ é€’ç»™`forEach`çš„é—­åŒ…æ˜¯ä¸`self`éš”ç¦»çš„ï¼Œå› ä¸ºå®ƒéœ€è¦ä¸€ä¸ªé`@Sendable`å‡½æ•°ã€‚

### Actor reentrancy

Actor-isolated functions are [reentrant](https://en.wikipedia.org/wiki/Reentrancy_(computing)). When an actor-isolated function suspends, reentrancy allows other work to execute on the actor before the original actor-isolated function resumes, which we refer to as *interleaving*. Reentrancy eliminates a source of deadlocks, where two actors depend on each other, can improve overall performance by not unnecessarily blocking work on actors, and offers opportunities for better scheduling of (e.g.) higher-priority tasks. However, it means that actor-isolated state can change across an `await` when an interleaved task mutates that state, meaning that developers must be sure not to break invariants across an await. In general, this is the [reason for requiring `await`](https://github.com/apple/swift-evolution/blob/main/proposals/0296-async-await.md#suspension-points) on asynchronous calls, because various state (e.g., global state) can change when a call suspends.

actoréš”ç¦»çš„å‡½æ•°æ˜¯[å¯é‡å…¥çš„](https://en.wikipedia.org/wiki/Reentrancy_(è®¡ç®—))ã€‚å½“ä¸€ä¸ªactoréš”ç¦»çš„å‡½æ•°æš‚åœæ—¶ï¼Œå¯é‡å…¥æ€§å…è®¸å…¶ä»–å·¥ä½œåœ¨åŸactoréš”ç¦»çš„å‡½æ•°æ¢å¤ä¹‹å‰åœ¨è¯¥actorä¸Šæ‰§è¡Œï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸º*äº¤é”™*ã€‚é‡å¿ƒæ¶ˆé™¤äº†ä¸€ä¸ªæ­»é”çš„æ¥æºï¼Œå³ä¸¤ä¸ªactorç›¸äº’ä¾èµ–ï¼Œå¯ä»¥é€šè¿‡ä¸ä¸å¿…è¦åœ°é˜»å¡actorä¸Šçš„å·¥ä½œæ¥æé«˜æ•´ä½“æ€§èƒ½ï¼Œå¹¶ä¸ºæ›´å¥½åœ°è°ƒåº¦ï¼ˆä¾‹å¦‚ï¼‰æ›´ä¼˜å…ˆçš„ä»»åŠ¡æä¾›æœºä¼šã€‚ç„¶è€Œï¼Œè¿™æ„å‘³ç€å½“äº¤é”™ä»»åŠ¡çªå˜çŠ¶æ€æ—¶ï¼Œactoréš”ç¦»çš„çŠ¶æ€å¯èƒ½ä¼šè·¨ `await` å‘ç”Ÿå˜åŒ–ï¼Œè¿™æ„å‘³ç€å¼€å‘è€…å¿…é¡»ç¡®ä¿ä¸æ‰“ç ´è·¨ç­‰å¾…çš„ä¸å˜æ€§ã€‚ä¸€èˆ¬æ¥è¯´ï¼Œè¿™æ˜¯åœ¨å¼‚æ­¥è°ƒç”¨ä¸­è¦æ±‚`await`çš„[åŸå› ](https://github.com/apple/swift-evolution/blob/main/proposals/0296-async-await.md#suspension-points)ï¼Œå› ä¸ºå½“è°ƒç”¨æš‚åœæ—¶ï¼Œå„ç§çŠ¶æ€ï¼ˆä¾‹å¦‚å…¨å±€çŠ¶æ€ï¼‰ä¼šå‘ç”Ÿå˜åŒ–ã€‚

This section explores the issue of reentrancy with examples that illustrate both the benefits and problems with both reentrant and non-reentrant actors, and settles on re-entrant actors. Alternatives Considered provides potential future directions to provide more control of re-entrancy, including [non-reentrant actors](#non-reentrancy) and [task-chain reentrancy](#task-chain-reentrancy).

æœ¬èŠ‚é€šè¿‡å®ä¾‹æ¢è®¨äº†é‡å…¥é—®é¢˜ï¼Œè¯´æ˜äº†é‡å…¥actorå’Œéé‡å…¥actorçš„å¥½å¤„å’Œé—®é¢˜ï¼Œå¹¶æœ€ç»ˆç¡®å®šäº†é‡å…¥actorã€‚è€ƒè™‘çš„æ›¿ä»£æ–¹æ¡ˆæä¾›äº†æ½œåœ¨çš„æœªæ¥æ–¹å‘ï¼Œä»¥æä¾›å¯¹é‡å…¥çš„æ›´å¤šæ§åˆ¶ï¼ŒåŒ…æ‹¬[éé‡å…¥actor](#non-reentrancy)å’Œ[ä»»åŠ¡é“¾é‡å…¥](#task-chain-reentrancy)ã€‚

#### "Interleaving" execution with reentrant actors

Reentrancy means that execution of asynchronous actor-isolated functions may "interleave" at suspension points, leading to increased complexity in programming with such actors, as every suspension point must be carefully inspected if the code *after* it depends on some invariants that could have changed before it suspended.

é‡å¿ƒæ„å‘³ç€å¼‚æ­¥actor-isolatedçš„å‡½æ•°çš„æ‰§è¡Œå¯èƒ½ä¼šåœ¨æš‚åœç‚¹ä¸Š "äº¤é”™"ï¼Œå¯¼è‡´ç”¨è¿™ç§actorç¼–ç¨‹çš„å¤æ‚æ€§å¢åŠ ï¼Œå› ä¸ºå¦‚æœ*åçš„ä»£ç ä¾èµ–äºä¸€äº›å¯èƒ½åœ¨æš‚åœå‰å‘ç”Ÿå˜åŒ–çš„ä¸å˜é‡ï¼Œåˆ™å¿…é¡»ä»”ç»†æ£€æŸ¥æ¯ä¸ªæš‚åœç‚¹ã€‚

Interleaving executions still respect the actor's "single-threaded illusion", i.e., no two functions will ever execute *concurrently* on any given actor. However they may *interleave* at suspension points. In broad terms this means that reentrant actors are *thread-safe* but are not automatically protecting from the "high level" kinds of races that may still occur, potentially invalidating invariants upon which an executing asynchronous function may be relying on. To further clarify the implications of this, let us consider the following actor, which thinks of an idea and then returns it, after telling its friend about it.

äº¤ç»‡æ‰§è¡Œä»ç„¶å°Šé‡actorçš„ "å•çº¿ç¨‹å¹»è§‰"ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œæ²¡æœ‰ä¸¤ä¸ªå‡½æ•°ä¼šåœ¨ä»»ä½•ç»™å®šçš„actorä¸Š*å¹¶å‘åœ°æ‰§è¡Œã€‚ç„¶è€Œï¼Œå®ƒä»¬å¯ä»¥åœ¨æš‚åœç‚¹ä¸Š*äº¤ç»‡ã€‚ä»å¹¿ä¹‰ä¸Šè®²ï¼Œè¿™æ„å‘³ç€å¯é‡å…¥actoræ˜¯*çº¿ç¨‹å®‰å…¨çš„*ï¼Œä½†å¹¶ä¸è‡ªåŠ¨ä¿æŠ¤ï¼Œå› ä¸º "é«˜æ°´å¹³ "çš„ç«èµ›ä»ç„¶å¯èƒ½å‘ç”Ÿï¼Œæœ‰å¯èƒ½ä½¿æ‰§è¡Œä¸­çš„å¼‚æ­¥å‡½æ•°æ‰€ä¾èµ–çš„ä¸å˜æ€§å¤±æ•ˆã€‚ä¸ºäº†è¿›ä¸€æ­¥æ¾„æ¸…è¿™ä¸ªé—®é¢˜çš„å«ä¹‰ï¼Œè®©æˆ‘ä»¬è€ƒè™‘ä¸‹é¢è¿™ä¸ªactorï¼Œå®ƒæƒ³åˆ°äº†ä¸€ä¸ªæƒ³æ³•ï¼Œç„¶ååœ¨å‘Šè¯‰å®ƒçš„æœ‹å‹ä¹‹åå°†å…¶è¿”å›ã€‚

```swift
actor Person {
  let friend: Friend
  
  // actor-isolated opinion
  var opinion: Judgment = .noIdea

  func thinkOfGoodIdea() async -> Decision {
    opinion = .goodIdea                       // <1>
    await friend.tell(opinion, heldBy: self)  // <2>
    return opinion // ğŸ¤¨                      // <3>
  }

  func thinkOfBadIdea() async -> Decision {
    opinion = .badIdea                       // <4>
    await friend.tell(opinion, heldBy: self) // <5>
    return opinion // ğŸ¤¨                     // <6>
  }
}
```

In the example above the `Person` can think of a good or bad idea, shares that opinion with a friend, and returns that opinion that it stored. Since the actor is reentrant this code is wrong and will return an arbitrary opinion if the actor begins to think of a few ideas at the same time.

åœ¨ä¸Šé¢çš„ä¾‹å­ä¸­ï¼Œ"äºº "å¯ä»¥æƒ³åˆ°ä¸€ä¸ªå¥½çš„æˆ–åçš„æƒ³æ³•ï¼Œä¸ä¸€ä¸ªæœ‹å‹åˆ†äº«è¿™ä¸ªæ„è§ï¼Œå¹¶è¿”å›å®ƒæ‰€å­˜å‚¨çš„æ„è§ã€‚ç”±äºactoræ˜¯å¯é‡å…¥çš„ï¼Œæ‰€ä»¥è¿™æ®µä»£ç æ˜¯é”™è¯¯çš„ï¼Œå¦‚æœactoråŒæ—¶å¼€å§‹æ€è€ƒå‡ ä¸ªæƒ³æ³•ï¼Œå°±ä¼šè¿”å›ä¸€ä¸ªä»»æ„çš„æ„è§ã€‚

This is exemplified by the following piece of code, exercising the `decisionMaker` actor:

ä»¥ä¸‹æ˜¯è¡Œä½¿ `decisionMaker` actorçš„ä»£ç ï¼Œå¯ä»¥è¯´æ˜è¿™ä¸€ç‚¹ã€‚

```swift
let goodThink = detach { await person.thinkOfGoodIdea() }  // runs async
let badThink = detach { await person.thinkOfBadIdea() } // runs async

let shouldBeGood = await goodThink.get()
let shouldBeBad = await badThink.get()

await shouldBeGood // could be .goodIdea or .badIdea â˜ ï¸
await shouldBeBad
```

This snippet _may_ result (depending on timing of the resumptions) in the following execution:

è¿™ä¸ªç‰‡æ®µ_å¯èƒ½ä¼šå¯¼è‡´ï¼ˆå–å†³äºæ¢å¤çš„æ—¶é—´ï¼‰ä»¥ä¸‹çš„æ‰§è¡Œã€‚

```swift
opinion = .goodIdea                // <1>
// suspend: await friend.tell(...) // <2>
opinion = .badIdea                 // | <4> (!)
// suspend: await friend.tell(...) // | <5>
// resume: await friend.tell(...)  // <2>
return opinion                     // <3>
// resume: await friend.tell(...)  // <5>
return opinion                     // <6>
```

But it _may_ also result in the "naively expected" execution, i.e. without interleaving, meaning that the issue will only show up intermittently, like many race conditions in concurrent code.

ä½†å®ƒä¹Ÿå¯èƒ½å¯¼è‡´ "å¤©çœŸé¢„æœŸ "çš„æ‰§è¡Œï¼Œå³æ²¡æœ‰äº¤ç»‡ï¼Œè¿™æ„å‘³ç€é—®é¢˜åªä¼šé—´æ­‡æ€§åœ°å‡ºç°ï¼Œå°±åƒå¹¶å‘ä»£ç ä¸­çš„è®¸å¤šç«èµ›æ¡ä»¶ã€‚

The potential for interleaved execution at suspension points is the primary reason for the requirement that every suspension point be [marked by `await`](https://github.com/apple/swift-evolution/blob/main/proposals/0296-async-await.md#suspension-points) in the source code, even though `await` itself has no semantic effect. It is an indicator that any shared state might change across the `await`, so one should avoid breaking invariants across an `await`, or otherwise depending on the state "before" to be identical to the state "after".

åœ¨æš‚åœç‚¹ä¸Šæœ‰å¯èƒ½å‡ºç°äº¤é”™æ‰§è¡Œï¼Œè¿™æ˜¯è¦æ±‚æ¯ä¸ªæš‚åœç‚¹åœ¨æºä»£ç ä¸­[ç”¨`await`æ ‡è®°](https://github.com/apple/swift-evolution/blob/main/proposals/0296-async-await.md#suspension-points)çš„ä¸»è¦åŸå› ï¼Œå°½ç®¡`await`æœ¬èº«æ²¡æœ‰è¯­ä¹‰ä½œç”¨ã€‚è¿™æ˜¯ä¸€ä¸ªæŒ‡æ ‡ï¼Œè¡¨æ˜ä»»ä½•å…±äº«çŠ¶æ€éƒ½å¯èƒ½åœ¨ `await` ä¸­å‘ç”Ÿå˜åŒ–ï¼Œæ‰€ä»¥åº”è¯¥é¿å…åœ¨ `await` ä¸­ç ´åä¸å˜æ€§ï¼Œæˆ–è€…ä¾èµ– "ä¹‹å‰ "çš„çŠ¶æ€ä¸ "ä¹‹å "çš„çŠ¶æ€ç›¸åŒã€‚

Generally speaking, the easiest way to avoid breaking invariants across an `await` is to encapsulate state updates in synchronous actor functions. Effectively, synchronous code in an actor provides a [critical section](https://en.wikipedia.org/wiki/Critical_section), whereas an `await` interrupts a critical section. For our example above, we could effect this change by separating "opinion formation" from "telling a friend your opinion". Indeed, telling your friend your opinion might reasonably cause you to change your opinion!

ä¸€èˆ¬æ¥è¯´ï¼Œé¿å…è·¨ `await` ç ´åä¸å˜æ€§çš„æœ€ç®€å•æ–¹æ³•æ˜¯å°†çŠ¶æ€æ›´æ–°å°è£…åœ¨åŒæ­¥actorå‡½æ•°ä¸­ã€‚å®é™…ä¸Šï¼Œactorä¸­çš„åŒæ­¥ä»£ç æä¾›äº†ä¸€ä¸ª[å…³é”®éƒ¨åˆ†](https://en.wikipedia.org/wiki/Critical_section)ï¼Œè€Œ`await`ä¸­æ–­äº†ä¸€ä¸ªå…³é”®éƒ¨åˆ†ã€‚å¯¹äºæˆ‘ä»¬ä¸Šé¢çš„ä¾‹å­ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡å°† "æ„è§å½¢æˆ "ä¸ "å‘Šè¯‰æœ‹å‹ä½ çš„æ„è§ "åˆ†å¼€æ¥å®ç°è¿™ä¸€å˜åŒ–ã€‚äº‹å®ä¸Šï¼Œå‘Šè¯‰ä½ çš„æœ‹å‹ä½ çš„è§‚ç‚¹å¯èƒ½ä¼šåˆç†åœ°å¯¼è‡´ä½ æ”¹å˜ä½ çš„è§‚ç‚¹ï¼"ã€‚

#### Deadlocks with non-reentrant actors

The opposite of reentrant actor functions are "non-reentrant" functions and actors. This means that while an actor is processing an incoming actor function call (message), it will *not* process any other message from its mailbox until it has completed running this initial function. Essentially, the entire actor is blocked from executing until that task completes.

ä¸å¯é‡å…¥çš„actorå‡½æ•°ç›¸åçš„æ˜¯ "ä¸å¯é‡å…¥ "çš„å‡½æ•°å’Œactorã€‚è¿™æ„å‘³ç€å½“ä¸€ä¸ªactoræ­£åœ¨å¤„ç†ä¸€ä¸ªä¼ å…¥çš„actorå‡½æ•°è°ƒç”¨ï¼ˆæ¶ˆæ¯ï¼‰æ—¶ï¼Œå®ƒå°†ä¸ä¼š*å¤„ç†æ¥è‡ªå…¶é‚®ç®±çš„ä»»ä½•å…¶ä»–æ¶ˆæ¯ï¼Œç›´åˆ°å®ƒå®Œæˆè¿è¡Œè¿™ä¸ªåˆå§‹å‡½æ•°ã€‚åŸºæœ¬ä¸Šï¼Œæ•´ä¸ªactorè¢«é˜»æ­¢æ‰§è¡Œï¼Œç›´åˆ°è¯¥ä»»åŠ¡å®Œæˆã€‚

If we take the example from the previous section and use a non-reentrant actor, it will execute correctly, because no work can be scheduled on the actor until `friend.tell` has completed:

å¦‚æœæˆ‘ä»¬ä»¥ä¸Šä¸€èŠ‚çš„ä¾‹å­ä¸ºä¾‹ï¼Œä½¿ç”¨ä¸€ä¸ªéé‡åº¦actorï¼Œå®ƒå°†æ­£ç¡®æ‰§è¡Œï¼Œå› ä¸ºåœ¨`friend.tell`å®Œæˆä¹‹å‰ï¼Œä¸èƒ½åœ¨actorä¸Šå®‰æ’å·¥ä½œã€‚

```swift
// assume non-reentrant
actor DecisionMaker {
  let friend: DecisionMaker
  var opinion: Judgment = .noIdea

  func thinkOfGoodIdea() async -> Decision {
    opinion = .goodIdea                                   
    await friend.tell(opinion, heldBy: self)
    return opinion // âœ… always .goodIdea
  }

  func thinkOfBadIdea() async -> Decision {
    opinion = .badIdea
    await friend.tell(opinion, heldBy: self)
    return opinion // âœ… always .badIdea
  }
}
```

However, non-entrancy can result in deadlock if a task involves calling back into the actor. For example, let's stretch this example further and have our friend try to convince us to change a bad idea:

ç„¶è€Œï¼Œå¦‚æœä¸€ä¸ªä»»åŠ¡æ¶‰åŠåˆ°å›è°ƒactorï¼Œéä¸­å¿ƒåŒ–å°±ä¼šå¯¼è‡´æ­»é”ã€‚ä¾‹å¦‚ï¼Œè®©æˆ‘ä»¬è¿›ä¸€æ­¥å»¶ä¼¸è¿™ä¸ªä¾‹å­ï¼Œè®©æˆ‘ä»¬çš„æœ‹å‹è¯•å›¾è¯´æœæˆ‘ä»¬æ”¹å˜ä¸€ä¸ªåä¸»æ„ã€‚

```swift
extension DecisionMaker {
  func tell(_ opinion: Judgment, heldBy friend: DecisionMaker) async {
    if opinion == .badIdea {
      await friend.convinceOtherwise(opinion)
    }
  }
}
```

With non-reentrant actors, `thinkOfGoodIdea()` will succeed under this implementation, because `tell` essentially does nothing. However, `thinkOfBadIdea()` will deadlock because the original decision maker (call it `A`) is locked when it calls `tell` on another decision maker (call it `B`). `B` then tries to convince `A` otherwise, but that call cannot execute because `A` is already locked. Hence, the actor itself deadlocks and cannot progress.

å¯¹äºéé‡è¹ˆè¦†è¾™çš„actorï¼Œ`thinkOfGoodIdea()'åœ¨è¿™ç§å®ç°ä¸‹ä¼šæˆåŠŸï¼Œå› ä¸º`tell`åŸºæœ¬ä¸Šä»€ä¹ˆéƒ½ä¸åšã€‚ç„¶è€Œï¼Œ`thinkOfBadIdea()`å°†é™·å…¥åƒµå±€ï¼Œå› ä¸ºåŸæ¥çš„å†³ç­–è€…ï¼ˆç§°ä¸ºAï¼‰åœ¨å¯¹å¦ä¸€ä¸ªå†³ç­–è€…ï¼ˆç§°ä¸ºBï¼‰è°ƒç”¨`tell`æ—¶è¢«é”å®šã€‚ç„¶åï¼Œ`B`è¯•å›¾è¯´æœ`A`ï¼Œä½†è¯¥è°ƒç”¨æ— æ³•æ‰§è¡Œï¼Œå› ä¸º`A`å·²ç»è¢«é”å®šã€‚å› æ­¤ï¼Œ`actor`æœ¬èº«é™·å…¥åƒµå±€ï¼Œæ— æ³•è¿›å±•ã€‚

> The term "deadlock" used in these discussions refer to actors asynchronously waiting on "each other," or on "future work of self". No thread blocking is necessary to manifest this issue.

> è¿™äº›è®¨è®ºä¸­ä½¿ç”¨çš„æœ¯è¯­ "æ­»é” "æ˜¯æŒ‡è¡Œä¸ºè€…å¼‚æ­¥åœ°ç­‰å¾… "å¯¹æ–¹ "æˆ– "è‡ªå·±çš„æœªæ¥å·¥ä½œ"ã€‚ä¸éœ€è¦çº¿ç¨‹é˜»å¡æ¥ä½“ç°è¿™ä¸ªé—®é¢˜ã€‚

In theory, a fully non-reentrant model would also deadlock when calling asynchronous functions on `self`. However, since such calls are statically determinable to be on `self`, they would execute immediately and therefore not block.

ç†è®ºä¸Šï¼Œä¸€ä¸ªå®Œå…¨ä¸é‡è¿›çš„æ¨¡å‹åœ¨è°ƒç”¨`self`ä¸Šçš„å¼‚æ­¥å‡½æ•°æ—¶ä¹Ÿä¼šå‡ºç°æ­»é”ã€‚ç„¶è€Œï¼Œç”±äºè¿™ç§è°ƒç”¨å¯ä»¥é™æ€åœ°ç¡®å®šæ˜¯åœ¨`self`ä¸Šï¼Œå®ƒä»¬ä¼šç«‹å³æ‰§è¡Œï¼Œå› æ­¤ä¸ä¼šé˜»å¡ã€‚

Deadlocks with non-reentrant actors could be detected with runtime tools that detect cyclic call graphs once they've occurred, much like tools exist to find reference cycles in data structures at runtime. However, such deadlocks cannot generally be identified statically (e.g., with the compiler or static analysis), because call graphs require whole-program knowledge and can change dynamically depending on the data provided to the program.

å¯ä»¥ç”¨è¿è¡Œæ—¶å·¥å…·æ¥æ£€æµ‹éå†å…¥actorçš„æ­»é”ï¼Œè¿™äº›å·¥å…·å¯ä»¥åœ¨æ­»é”å‘ç”Ÿåæ£€æµ‹å¾ªç¯è°ƒç”¨å›¾ï¼Œå°±åƒåœ¨è¿è¡Œæ—¶æ£€æµ‹æ•°æ®ç»“æ„ä¸­çš„å¼•ç”¨å¾ªç¯ä¸€æ ·ã€‚ç„¶è€Œï¼Œè¿™ç§æ­»é”é€šå¸¸ä¸èƒ½è¢«é™æ€åœ°è¯†åˆ«ï¼ˆä¾‹å¦‚ï¼Œç”¨ç¼–è¯‘å™¨æˆ–é™æ€åˆ†æï¼‰ï¼Œå› ä¸ºè°ƒç”¨å›¾éœ€è¦æ•´ä¸ªç¨‹åºçš„çŸ¥è¯†ï¼Œå¹¶ä¸”å¯ä»¥æ ¹æ®æä¾›ç»™ç¨‹åºçš„æ•°æ®è€ŒåŠ¨æ€å˜åŒ–ã€‚

Deadlocked actors would be sitting around as inactive zombies forever. Some runtimes solve deadlocks like this by making every single actor call have a timeout (such timeouts are already useful for distributed actor systems). This would mean that each `await` could potentially `throw`, and that either timeouts or deadlock detection would have to always be enabled. We feel this would be prohibitively expensive, because we envision actors being used in the vast majority of concurrent Swift applications. It would also muddy the waters with respect to cancellation, which is intentionally designed to be explicit and cooperative. Therefore, we feel that the approach of automatically cancelling on deadlocks does not fit well with the direction of Swift Concurrency.

æ­»é”çš„actorå°†æ°¸è¿œä½œä¸ºä¸æ´»è·ƒçš„åƒµå°¸ååœ¨é‚£é‡Œã€‚ä¸€äº›è¿è¡Œæ—¶ä¸ºäº†è§£å†³è¿™æ ·çš„æ­»é”é—®é¢˜ï¼Œè®©æ¯ä¸ªactorçš„è°ƒç”¨éƒ½æœ‰ä¸€ä¸ªè¶…æ—¶æ—¶é—´ï¼ˆè¿™æ ·çš„è¶…æ—¶æ—¶é—´å¯¹äºåˆ†å¸ƒå¼actorç³»ç»Ÿå·²ç»å¾ˆæœ‰ç”¨äº†ï¼‰ã€‚è¿™æ„å‘³ç€æ¯ä¸ª "ç­‰å¾… "éƒ½æœ‰å¯èƒ½ "æŠ›å‡º"ï¼Œè€Œè¶…æ—¶æˆ–æ­»é”æ£€æµ‹éƒ½å¿…é¡»å§‹ç»ˆè¢«å¯ç”¨ã€‚æˆ‘ä»¬è®¤ä¸ºè¿™å°†æ˜¯éå¸¸æ˜‚è´µçš„ï¼Œå› ä¸ºæˆ‘ä»¬è®¾æƒ³åœ¨ç»å¤§å¤šæ•°å¹¶å‘çš„Swiftåº”ç”¨ä¸­éƒ½ä¼šä½¿ç”¨actorã€‚è¿™ä¹Ÿä¼šä½¿å–æ¶ˆæ–¹é¢çš„æ°´å˜å¾—æµ‘æµŠï¼Œè€Œå–æ¶ˆæ˜¯æœ‰æ„è®¾è®¡æˆæ˜ç¡®å’Œåˆä½œçš„ã€‚å› æ­¤ï¼Œæˆ‘ä»¬è§‰å¾—è‡ªåŠ¨å–æ¶ˆæ­»é”çš„æ–¹æ³•å¹¶ä¸ç¬¦åˆ Swift å¹¶å‘çš„æ–¹å‘ã€‚

#### Unnecessary blocking with non-reentrant actors

Consider an actor that handles the download of various images and maintains a cache of what it has downloaded to make subsequent accesses faster:

è€ƒè™‘ä¸€ä¸ªå¤„ç†å„ç§å›¾ç‰‡ä¸‹è½½çš„actorï¼Œå¹¶ä¿æŒå¯¹å·²ä¸‹è½½å†…å®¹çš„ç¼“å­˜ï¼Œä»¥ä½¿åç»­è®¿é—®æ›´å¿«ã€‚

```swift
// assume non-reentrant
actor ImageDownloader { 
  var cache: [URL: Image] = [:]

  func getImage(_ url: URL) async -> Image {
    if let cachedImage = cache[url] {
      return cachedImage
    }
    
    let data = await download(url)
    let image = await Image(decoding: data)
    return cache[url, default: image]
  }
}
```

This actor is functionally correct, whether it is re-entrant or not. However, if it is non-reentrant, it will completely serialize the download of images: once a single client asked for an image, all other clients are blocked from starting any requests--even ones that would hit the cache or which ask for images at different URLs---until that first client has had its image fully downloaded and decoded.

è¿™ä¸ªactoråœ¨åŠŸèƒ½ä¸Šæ˜¯æ­£ç¡®çš„ï¼Œä¸ç®¡å®ƒæ˜¯å¦æ˜¯å¯é‡å…¥çš„ã€‚ç„¶è€Œï¼Œå¦‚æœå®ƒæ˜¯ä¸å¯é€†çš„ï¼Œå®ƒå°†å®Œå…¨åºåˆ—åŒ–å›¾ç‰‡çš„ä¸‹è½½ï¼šä¸€æ—¦ä¸€ä¸ªå®¢æˆ·ç«¯è¯·æ±‚äº†ä¸€å¼ å›¾ç‰‡ï¼Œæ‰€æœ‰å…¶ä»–çš„å®¢æˆ·ç«¯å°†è¢«é˜»æ­¢å¼€å§‹ä»»ä½•è¯·æ±‚--å³ä½¿æ˜¯é‚£äº›ä¼šå‡»ä¸­ç¼“å­˜æˆ–åœ¨ä¸åŒçš„URLä¸Šè¯·æ±‚å›¾ç‰‡çš„è¯·æ±‚--ç›´åˆ°ç¬¬ä¸€ä¸ªå®¢æˆ·ç«¯å°†å…¶å›¾ç‰‡å®Œå…¨ä¸‹è½½å’Œè§£ç ã€‚

With a reentrant actor, multiple clients can fetch images independently, so that (say) they can all be at different stages of downloading and decoding an image. The serialized execution of partial tasks on the actor ensures that the cache itself can never get corrupted. At worst, two clients might ask for the same image URL at the same time, in which there will be some redundant work. 

æœ‰äº†å¯é‡å…¥çš„actorï¼Œå¤šä¸ªå®¢æˆ·ç«¯å¯ä»¥ç‹¬ç«‹åœ°è·å–å›¾åƒï¼Œè¿™æ ·ï¼ˆæ¯”å¦‚ï¼‰ä»–ä»¬éƒ½å¯ä»¥å¤„äºä¸‹è½½å’Œè§£ç å›¾åƒçš„ä¸åŒé˜¶æ®µã€‚actorä¸Šéƒ¨åˆ†ä»»åŠ¡çš„åºåˆ—åŒ–æ‰§è¡Œç¡®ä¿äº†ç¼“å­˜æœ¬èº«ä¸ä¼šè¢«ç ´åã€‚åœ¨æœ€åçš„æƒ…å†µä¸‹ï¼Œä¸¤ä¸ªå®¢æˆ·å¯èƒ½ä¼šåŒæ—¶è¦æ±‚è·å¾—ç›¸åŒçš„å›¾åƒURLï¼Œå…¶ä¸­ä¼šæœ‰ä¸€äº›å¤šä½™çš„å·¥ä½œã€‚

#### Existing practice

There are a number of existing actor implementations that have considered the notion of reentrancy:

æœ‰ä¸€äº›ç°æœ‰çš„actorå®ç°å·²ç»è€ƒè™‘äº†é‡å…¥çš„æ¦‚å¿µã€‚

* Erlang/Elixir ([gen_server](https://medium.com/@eduardbme/erlang-gen-server-never-call-your-public-interface-functions-internally-c17c8f28a1ee)) showcases a simple "loop/deadlock" scenario and how to detect and fix it,
* Akka ([Persistence persist/persistAsync](https://doc.akka.io/docs/akka/current/persistence.html#relaxed-local-consistency-requirements-and-high-throughput-use-cases) is effectively _non-reentrant behavior by default_, and specific APIs are designed to allow programmers to _opt into_ reentrant whenever it would be needed. In the linked documentation `persistAsync` is the re-entrant version of the API, and it is used _very rarely_ in practice. Akka persistence and this API has been used to implement bank transactions and process managers, by relying on the non-reentrancy of `persist()` as a killer feature, making implementations simple to understand and _safe_. Note that Akka is built on top of Scala, which does not provide `async`/`await`. This means that mailbox-processing methods are more synchronous in nature, and rather than block the actor while waiting for a response, they would handle the response as a separate message receipt.
* Orleans ([grains](https://dotnet.github.io/orleans/docs/grains/reentrancy.html)) are also non-reentrant by default, but offer extensive configuration around reentrancy. Grains and specific methods can be marked as being re-entrant, and there is even a dynamic mechanism by which one can implement a run-time predicate to determine whether an invocation can interleave. Orleans is perhaps closest to the Swift approach described here, because it is built on top of a language that provides `async`/`await` (C#). Note that Orleans *had* a feature called [call-chain reentrancy](https://dotnet.github.io/orleans/docs/grains/reentrancy.html#reentrancy-within-a-call-chain), which we feel is a promising potential direction: we cover it later in this proposal in our section on [task-chain reentrancy](#task-chain-reentrancy).

* Erlang/Elixirï¼ˆ[gen_server](https://medium.com/@eduardbme/erlang-gen-server-never-call-your-public-interface-function-internally-c17c8f28a1ee)ï¼‰å±•ç¤ºäº†ä¸€ä¸ªç®€å•çš„ "å¾ªç¯/æ­»é” "åœºæ™¯ä»¥åŠå¦‚ä½•æ£€æµ‹å’Œä¿®å¤å®ƒã€‚
* Akkaï¼ˆ[Persistence persist/persistAsync](https://doc.akka.io/docs/akka/current/persistence.html#relaxed-local-consistency-requirements-and-high-throughput-use-cases)å®é™…ä¸Šæ˜¯é»˜è®¤çš„_éé‡å…¥è¡Œä¸ºï¼Œç‰¹å®šçš„APIè¢«è®¾è®¡ä¸ºå…è®¸ç¨‹åºå‘˜åœ¨éœ€è¦æ—¶_é€‰æ‹©è¿›å…¥_é‡å…¥ã€‚åœ¨é“¾æ¥çš„æ–‡æ¡£ä¸­ï¼Œ`persistAsync`æ˜¯APIçš„å¯é‡å…¥ç‰ˆæœ¬ï¼Œå®ƒåœ¨å®è·µä¸­å¾ˆå°‘è¢«ä½¿ç”¨ã€‚AkkaæŒä¹…åŒ–å’Œè¿™ä¸ªAPIå·²ç»è¢«ç”¨æ¥å®ç°é“¶è¡Œäº¤æ˜“å’Œæµç¨‹ç®¡ç†ï¼Œä¾é `persist()`çš„éé‡å…¥æ€§ä½œä¸ºæ€æ‰‹é”ï¼Œä½¿å¾—å®ç°ç®€å•æ˜“æ‡‚ä¸”_å®‰å…¨_ã€‚æ³¨æ„ï¼ŒAkkaæ˜¯å»ºç«‹åœ¨Scalaä¹‹ä¸Šçš„ï¼ŒScalaä¸æä¾›`async`/`await`ã€‚è¿™æ„å‘³ç€é‚®ç®±å¤„ç†æ–¹æ³•åœ¨æœ¬è´¨ä¸Šæ›´å…·æœ‰åŒæ­¥æ€§ï¼Œä¸å…¶åœ¨ç­‰å¾…å“åº”æ—¶é˜»å¡actorï¼Œä¸å¦‚å°†å“åº”ä½œä¸ºä¸€ä¸ªå•ç‹¬çš„æ¶ˆæ¯æ¥æ”¶æ¥å¤„ç†ã€‚
* Orleansï¼ˆ[grains](https://dotnet.github.io/orleans/docs/grains/reentrancy.html)ï¼‰é»˜è®¤ä¹Ÿæ˜¯éé‡å…¥æ€§çš„ï¼Œä½†å›´ç»•é‡å…¥æ€§æä¾›äº†å¹¿æ³›çš„é…ç½®ã€‚è°·ç‰©å’Œç‰¹å®šçš„æ–¹æ³•å¯ä»¥è¢«æ ‡è®°ä¸ºå¯é‡å…¥ï¼Œç”šè‡³è¿˜æœ‰ä¸€ç§åŠ¨æ€æœºåˆ¶ï¼Œå¯ä»¥å®ç°ä¸€ä¸ªè¿è¡Œæ—¶è°“è¯æ¥ç¡®å®šä¸€ä¸ªè°ƒç”¨æ˜¯å¦å¯ä»¥äº¤é”™ã€‚Orleansä¹Ÿè®¸æœ€æ¥è¿‘è¿™é‡Œæè¿°çš„Swiftæ–¹æ³•ï¼Œå› ä¸ºå®ƒæ˜¯å»ºç«‹åœ¨æä¾›`async`/`await`çš„è¯­è¨€ä¹‹ä¸Šçš„ï¼ˆC#ï¼‰ã€‚è¯·æ³¨æ„ï¼ŒOrleans *æœ‰ä¸€ä¸ªå«åš[è°ƒç”¨é“¾é‡å…¥](https://dotnet.github.io/orleans/docs/grains/reentrancy.html#reentrancy-within-a-call-chain)çš„åŠŸèƒ½ï¼Œæˆ‘ä»¬è®¤ä¸ºè¿™æ˜¯ä¸€ä¸ªå¾ˆæœ‰å‰é€”çš„æ½œåœ¨æ–¹å‘ï¼šæˆ‘ä»¬åœ¨æœ¬ææ¡ˆåé¢çš„[ä»»åŠ¡é“¾é‡å…¥](#task-chain-reentrancy)ä¸€èŠ‚ä¸­ä»‹ç»äº†å®ƒã€‚

#### Reentrancy Summary

This proposal provides only reentrant actors. However, the [Future Directions](#future-directions) section describes potential future design directions that could add opt-in non-reentrancy.

æœ¬ææ¡ˆåªæä¾›äº†å¯é‡å…¥çš„actorã€‚ç„¶è€Œï¼Œ[æœªæ¥æ–¹å‘](#future-directions)éƒ¨åˆ†æè¿°äº†æ½œåœ¨çš„æœªæ¥è®¾è®¡æ–¹å‘ï¼Œå¯ä»¥å¢åŠ é€‰æ‹©çš„éé‡å…¥æ€§ã€‚

> **Rationale**: Reentrancy by default all but eliminates the potential for deadlocks. Moreover, it helps ensure that actors can make timely progress within a concurrent system, and that a particular actor does not end up unnecessarily blocked on a long-running asynchronous operation (say, downloading a file). The mechanisms for ensuring safe interleaving, such as using synchronous code when performing mutations and being careful not to break invariants across `await` calls, are already present in the proposal.

> **ç†ç”±**ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œé‡å…¥å¯ä»¥æ¶ˆé™¤æ­»é”çš„å¯èƒ½æ€§ã€‚æ­¤å¤–ï¼Œå®ƒè¿˜æœ‰åŠ©äºç¡®ä¿actoråœ¨å¹¶å‘ç³»ç»Ÿä¸­èƒ½åŠæ—¶å–å¾—è¿›å±•ï¼Œå¹¶ç¡®ä¿ç‰¹å®šçš„actorä¸ä¼šåœ¨é•¿æœŸè¿è¡Œçš„å¼‚æ­¥æ“ä½œï¼ˆä¾‹å¦‚ï¼Œä¸‹è½½æ–‡ä»¶ï¼‰ä¸­å‡ºç°ä¸å¿…è¦çš„é˜»å¡ã€‚ç¡®ä¿å®‰å…¨äº¤ç»‡çš„æœºåˆ¶ï¼Œä¾‹å¦‚åœ¨æ‰§è¡Œçªå˜æ—¶ä½¿ç”¨åŒæ­¥ä»£ç ï¼Œå¹¶æ³¨æ„ä¸ç ´åè·¨ `await` è°ƒç”¨çš„ä¸å˜æ€§ï¼Œå·²ç»å­˜åœ¨äºè¯¥ææ¡ˆä¸­ã€‚

### Protocol conformances

All actor types implicitly conform to a new protocol, `Actor`:

æ‰€æœ‰çš„æ¼”å‘˜ç±»å‹éƒ½éšå«åœ°ç¬¦åˆä¸€ä¸ªæ–°çš„åè®®ï¼Œ`Actor`ã€‚

```swift
protocol Actor : AnyObject, Sendable { }
```

> **Note**: The definition of the `Actor` protocol is intentionally left blank. The [custom executors proposal][customexecs] will introduce requirements into the `Actor` protocol. These requirements will be implicitly synthesized by the implementation when not explicitly provided, but can be explicitly provided to allow actors to control their own serialized execution.

> **æ³¨æ„**ã€‚`Actor`åè®®çš„å®šä¹‰æ˜¯æ•…æ„ç•™ç™½çš„ã€‚[è‡ªå®šä¹‰æ‰§è¡Œå™¨å»ºè®®][è‡ªå®šä¹‰æ‰§è¡Œå™¨]å°†åœ¨`Actor`åè®®ä¸­å¼•å…¥éœ€æ±‚ã€‚å½“æ²¡æœ‰æ˜ç¡®æä¾›æ—¶ï¼Œè¿™äº›è¦æ±‚å°†è¢«å®ç°éšå«åœ°åˆæˆï¼Œä½†å¯ä»¥æ˜ç¡®åœ°æä¾›ï¼Œä»¥å…è®¸actoræ§åˆ¶è‡ªå·±çš„åºåˆ—åŒ–æ‰§è¡Œã€‚

The `Actor` protocol can be used to write generic operations that work across all actors, including extending all actor types with new operations. As with actor types, instance properties, functions, and subscripts defined on the `Actor` protocol (including extensions thereof) are actor-isolated to the `self` actor. For example, 

actor "åè®®å¯ä»¥ç”¨æ¥ç¼–å†™é€‚ç”¨äºæ‰€æœ‰actorçš„é€šç”¨æ“ä½œï¼ŒåŒ…æ‹¬ç”¨æ–°çš„æ“ä½œæ‰©å±•æ‰€æœ‰actorç±»å‹ã€‚ä¸actorç±»å‹ä¸€æ ·ï¼Œåœ¨ `Actor` åè®®ä¸Šå®šä¹‰çš„å®ä¾‹å±æ€§ã€å‡½æ•°å’Œå­æ ‡å·ï¼ˆåŒ…æ‹¬å…¶æ‰©å±•ï¼‰æ˜¯ä¸ `self` actoréš”ç¦»çš„ã€‚ä¾‹å¦‚ã€‚

```swift
protocol DataProcessible: Actor {  // only actor types can conform to this protocol
  var data: Data { get }           // actor-isolated to self
}

extension DataProcessible {
  func compressData() -> Data {    // actor-isolated to self
    // use data synchronously
  }
}

actor MyProcessor : DataProcessible {
  var data: Data                   // okay, actor-isolated to self
  
  func doSomething() {
    let newData = compressData()   // okay, calling actor-isolated method on self
    // use new data
  }
}

func doProcessing<T: DataProcessible>(processor: T) async {
  await processor.compressData() // not actor-isolated, so we must interact asynchronously with the actor
}
```

No other kind of concrete type (class, enum, struct, etc.) can conform to the `Actor` protocol, because they cannot define actor-isolated operations.

å…¶ä»–ç±»å‹çš„å…·ä½“ç±»å‹ï¼ˆç±»ã€æšä¸¾ã€ç»“æ„ç­‰ï¼‰éƒ½ä¸èƒ½ç¬¦åˆ `Actor` åè®®ï¼Œå› ä¸ºå®ƒä»¬ä¸èƒ½å®šä¹‰ä¸è¡Œä¸ºè€…éš”ç¦»çš„æ“ä½œã€‚

Actors can also conform to protocols with `async` requirements, because all clients will already have to interact with those requirements asynchronously, giving the actor the ability to protect its isolated state. For example:

actorä¹Ÿå¯ä»¥ç¬¦åˆå…·æœ‰ `async` è¦æ±‚çš„åè®®ï¼Œå› ä¸ºæ‰€æœ‰çš„å®¢æˆ·éƒ½å·²ç»ä¸å¾—ä¸ä¸è¿™äº›è¦æ±‚è¿›è¡Œå¼‚æ­¥äº¤äº’ï¼Œè¿™å°±ä½¿actoræœ‰èƒ½åŠ›ä¿æŠ¤å…¶å­¤ç«‹çš„çŠ¶æ€ã€‚æ¯”å¦‚è¯´ã€‚

```swift
protocol Server {
  func send<Message: MessageType>(message: Message) async throws -> Message.Reply
}

actor MyActor: Server {
  func send<Message: MessageType>(message: Message) async throws -> Message.Reply { // okay: this method is actor-isolated to 'self', satisfies asynchronous requirement
  }
}
```

Actors cannot otherwise be made to conform to non-`Actor` protocols with synchronous requirements. However, there is a separate proposal on [controlling actor isolation][isolationcontrol] that allows such conformances when they can implemented in a manner that does not reference any mutable actor state.

actorä¸èƒ½è¢«ç”¨æ¥ç¬¦åˆå…·æœ‰åŒæ­¥è¦æ±‚çš„é `actor` åè®®ã€‚ç„¶è€Œï¼Œæœ‰ä¸€ä¸ªå…³äº[æ§åˆ¶actoréš”ç¦»][isolationcontrol]çš„å•ç‹¬æè®®ï¼Œå½“å®ƒä»¬èƒ½å¤Ÿä»¥ä¸å¼•ç”¨ä»»ä½•mutableactorçŠ¶æ€çš„æ–¹å¼å®ç°æ—¶ï¼Œå…è®¸è¿™ç§ç¬¦åˆæ€§ã€‚

## Detailed design

### Actors

An actor type can be declared with the `actor` keyword:

å¯ä»¥ç”¨`actor`å…³é”®å­—æ¥å£°æ˜ä¸€ä¸ªæ¼”å‘˜ç±»å‹ã€‚

```swift
/// Declares a new type BankAccount
actor BankAccount {
  // ...
}
```

Each instance of the actor represents a unique actor. The term "actor" can be used to refer to either an instance or the type; where necessary, one can refer to the "actor instance" or "actor type" to disambiguate.

æ¯ä¸ªactorçš„å®ä¾‹éƒ½ä»£è¡¨ä¸€ä¸ªå”¯ä¸€çš„actorã€‚æœ¯è¯­ `actor` å¯ä»¥ç”¨æ¥æŒ‡ä»£å®ä¾‹æˆ–ç±»å‹ï¼›åœ¨å¿…è¦æ—¶ï¼Œäººä»¬å¯ä»¥æŒ‡ä»£ "actorå®ä¾‹ "æˆ– "actorç±»å‹ "ä»¥æ¶ˆé™¤æ­§ä¹‰ã€‚

Actors are similar to other concrete nominal types in Swift (enums, structs, and classes). Actor types can have `static` and instance methods, properties, and subscripts. They have stored properties and initializers like structs and classes. They are reference types like classes, but do not support inheritance, and therefore do not have (or need) features such as `required` and `convenience` initializers, overriding, or `class` members, `open` and `final`. Where actor types differ in behavior from other types is primarily driven by the rules of actor isolation, described below.

actorç±»ä¼¼äºSwiftä¸­çš„å…¶ä»–å…·ä½“åä¹‰ç±»å‹ï¼ˆæšä¸¾ã€ç»“æ„å’Œç±»ï¼‰ã€‚actorç±»å‹å¯ä»¥æœ‰ "é™æ€ "å’Œå®ä¾‹æ–¹æ³•ã€å±æ€§å’Œå­æ ‡å·ã€‚å®ƒä»¬åƒç»“æ„ä½“å’Œç±»ä¸€æ ·æœ‰å­˜å‚¨å±æ€§å’Œåˆå§‹åŒ–å™¨ã€‚å®ƒä»¬åƒç±»ä¸€æ ·æ˜¯å¼•ç”¨ç±»å‹ï¼Œä½†ä¸æ”¯æŒç»§æ‰¿ï¼Œå› æ­¤æ²¡æœ‰ï¼ˆæˆ–ä¸éœ€è¦ï¼‰è¯¸å¦‚ `required` å’Œ `convenience` åˆå§‹åŒ–å™¨ã€é‡å†™ã€æˆ– `class` æˆå‘˜ã€`open` å’Œ `final` ç­‰åŠŸèƒ½ã€‚actorç±»å‹åœ¨è¡Œä¸ºä¸Šä¸å…¶ä»–ç±»å‹çš„ä¸åŒä¹‹å¤„ä¸»è¦æ˜¯ç”±actor isolationçš„è§„åˆ™é©±åŠ¨çš„ï¼Œå¦‚ä¸‹æ‰€è¿°ã€‚

By default, the instance methods, properties, and subscripts of an actor have an isolated `self` parameter. This is true even for methods added retroactively on an actor via an extension, like any other Swift type. Static methods, properties, and subscripts do not have a `self` parameter that is an instance of the actor, so they are not actor-isolated.

é»˜è®¤æƒ…å†µä¸‹ï¼Œactorçš„å®ä¾‹æ–¹æ³•ã€å±æ€§å’Œå­æ ‡æœ‰ä¸€ä¸ªå­¤ç«‹çš„`self`å‚æ•°ã€‚å³ä½¿æ˜¯é€šè¿‡æ‰©å±•åœ¨actorä¸Šè¿½æº¯æ·»åŠ çš„æ–¹æ³•ä¹Ÿæ˜¯å¦‚æ­¤ï¼Œå°±åƒå…¶ä»–Swiftç±»å‹ä¸€æ ·ã€‚é™æ€æ–¹æ³•ã€å±æ€§å’Œå­è¯­å¥æ²¡æœ‰ä¸€ä¸ªä½œä¸ºactorå®ä¾‹çš„`self`å‚æ•°ï¼Œæ‰€ä»¥å®ƒä»¬ä¸æ˜¯ä¸actoréš”ç¦»çš„ã€‚

```swift
extension BankAccount {
  func acceptTransfer(amount: Double) async { // actor-isolated
    balance += amount
  }
}  
```

### Actor isolation checking

Any given declaration in a program is either actor-isolated or is non-isolated. A function (including accessors) is actor-isolated if it is defined on an actor type (including protocols where `Self` conforms to `Actor`, and extensions thereof). A mutable instance property or instance subscript is actor-isolated if it is defined on an actor type. Declarations that are not actor-isolated are called non-isolated.

ç¨‹åºä¸­çš„ä»»ä½•ç»™å®šçš„å£°æ˜è¦ä¹ˆæ˜¯ä¸actor-isolatedçš„ï¼Œè¦ä¹ˆæ˜¯ééš”ç¦»çš„ã€‚å¦‚æœä¸€ä¸ªå‡½æ•°ï¼ˆåŒ…æ‹¬è®¿é—®å™¨ï¼‰å®šä¹‰åœ¨ä¸€ä¸ªactorç±»å‹ä¸Šï¼ˆåŒ…æ‹¬`Self`ç¬¦åˆ`Actor`çš„åè®®ï¼Œä»¥åŠå…¶æ‰©å±•ï¼‰ï¼Œé‚£ä¹ˆå®ƒå°±æ˜¯actor-isolatedçš„ã€‚å¦‚æœä¸€ä¸ªmutableçš„å®ä¾‹å±æ€§æˆ–å®ä¾‹ä¸‹æ ‡æ˜¯å®šä¹‰åœ¨ä¸€ä¸ªactorç±»å‹ä¸Šçš„ï¼Œé‚£ä¹ˆå®ƒå°±æ˜¯ä¸actor-isolatedçš„ã€‚ä¸è¢«actor-isolatedçš„å£°æ˜è¢«ç§°ä¸ºééš”ç¦»çš„ã€‚

The actor isolation rules are checked in a number of places, where two different declarations need to be compared to determine if their usage together maintains actor isolation. There are several such places:

actor isolationè§„åˆ™åœ¨å¾ˆå¤šåœ°æ–¹è¢«æ£€æŸ¥ï¼Œåœ¨è¿™äº›åœ°æ–¹ï¼Œéœ€è¦å¯¹ä¸¤ä¸ªä¸åŒçš„å£°æ˜è¿›è¡Œæ¯”è¾ƒï¼Œä»¥ç¡®å®šå®ƒä»¬åœ¨ä¸€èµ·çš„ä½¿ç”¨æ˜¯å¦ä¿æŒäº†actorçš„éš”ç¦»ã€‚æœ‰å‡ ä¸ªè¿™æ ·çš„åœ°æ–¹ã€‚

* When the definition of one declaration (e.g., the body of a function) references another declaration, e.g., calling a function, accessing a property, or evaluating a subscript.
* When one declaration satisfies a protocol requirement.

* å½“ä¸€ä¸ªå£°æ˜çš„å®šä¹‰ï¼ˆä¾‹å¦‚ï¼Œä¸€ä¸ªå‡½æ•°çš„ä¸»ä½“ï¼‰å¼•ç”¨å¦ä¸€ä¸ªå£°æ˜æ—¶ï¼Œä¾‹å¦‚ï¼Œè°ƒç”¨ä¸€ä¸ªå‡½æ•°ï¼Œè®¿é—®ä¸€ä¸ªå±æ€§ï¼Œæˆ–è¯„ä¼°ä¸€ä¸ªä¸‹æ ‡ã€‚
* å½“ä¸€ä¸ªå£°æ˜æ»¡è¶³äº†ä¸€ä¸ªåè®®è¦æ±‚æ—¶ã€‚

We'll describe each scenario in detail.

æˆ‘ä»¬å°†è¯¦ç»†æè¿°æ¯ç§æƒ…å†µã€‚

#### References and actor isolation

An actor-isolated non-`async` declaration can only be synchronously accessed from another declaration that is isolated to the same actor. For synchronous access to an actor-isolated function, the function must be called from another actor-isolated function. For synchronous access to an actor-isolated instance property or instance subscript, the instance itself must be actor-isolated.

ä¸€ä¸ªä¸actor-isolatedçš„é`async`å£°æ˜åªèƒ½ä»å¦ä¸€ä¸ªä¸åŒä¸€actor isolationçš„å£°æ˜ä¸­è¢«åŒæ­¥è®¿é—®ã€‚å¯¹äºåŒæ­¥è®¿é—®ä¸€ä¸ªä¸actor-isolatedçš„å‡½æ•°ï¼Œè¯¥å‡½æ•°å¿…é¡»ä»å¦ä¸€ä¸ªä¸actor-isolatedçš„å‡½æ•°ä¸­è°ƒç”¨ã€‚å¯¹äºåŒæ­¥è®¿é—®ä¸€ä¸ªä¸actor-isolatedçš„å®ä¾‹å±æ€§æˆ–å®ä¾‹ä¸‹æ ‡ï¼Œè¯¥å®ä¾‹æœ¬èº«å¿…é¡»æ˜¯ä¸actor-isolatedçš„ã€‚

An actor-isolated declaration can be asynchronously accessed from any declaration, whether it is isolated to another actor or is non-isolated. Such accesses are asynchronous operations, and therefore must be annotated with `await`. Semantically, the progam will switch to the actor to perform the synchronous operation, and then switch back to the caller's executor afterward.

ä¸€ä¸ªè¢«actor-isolatedçš„å£°æ˜å¯ä»¥ä»ä»»ä½•å£°æ˜ä¸­è¢«å¼‚æ­¥è®¿é—®ï¼Œæ— è®ºå®ƒæ˜¯è¢«éš”ç¦»åˆ°å¦ä¸€ä¸ªactorè¿˜æ˜¯ä¸è¢«éš”ç¦»ã€‚è¿™æ ·çš„è®¿é—®æ˜¯å¼‚æ­¥æ“ä½œï¼Œå› æ­¤å¿…é¡»ç”¨`await`æ¥æ³¨é‡Šã€‚ä»è¯­ä¹‰ä¸Šè®²ï¼Œç¨‹åºå°†åˆ‡æ¢åˆ°æ‰§è¡Œå™¨æ¥æ‰§è¡ŒåŒæ­¥æ“ä½œï¼Œä¹‹åå†åˆ‡æ¢å›è°ƒç”¨è€…çš„æ‰§è¡Œå™¨ã€‚

For example:

ä¾‹å¦‚ï¼š

```swift
actor MyActor {
  let name: String
  var counter: Int = 0
  func f()
}

extension MyActor {
  func g(other: MyActor) async {
    print(name)                // okay, name is isolated to "self"
    print(other.name)          // error: name is isolated to "self", not "other"
    print(await other.name)    // okay, asynchronous access
    print(counter)             // okay, g() is isolated to "self"
    print(other.counter)       // error: g() is isolated to "self", not "other"
    print(await other.counter) // okay, asynchronous access
    f()                        // okay, f() is isolated to "self"
    await other.f()            // okay, other is not isolated to "self" but asynchronous access is permitted
  }
}
```

#### Protocol conformance

When a given declaration (the "witness") satisfies a protocol requirement (the "requirement"), the protocol requirement can be satisfied by the witness if:

å½“æŸé¡¹å£°æ˜ï¼ˆ"è¯äºº"ï¼‰æ»¡è¶³æŸé¡¹åè®®è¦æ±‚ï¼ˆ"è¦æ±‚"ï¼‰æ—¶ï¼Œåœ¨ä»¥ä¸‹æƒ…å†µä¸‹ï¼Œè¯äººå¯ä»¥æ»¡è¶³è¯¥åè®®è¦æ±‚ã€‚

* The requirement is `async`, or
* the requirement and witness are both actor-isolated.

* éœ€æ±‚æ˜¯ "async"ï¼Œæˆ–
* éœ€æ±‚å’Œè§è¯è€…éƒ½æ˜¯è¡Œä¸ºè€…éš”ç¦»çš„ã€‚

An actor can satisfy an asynchronous requirement because any uses of the requirement are asynchronous, and can therefore suspend until the actor is available to execute them. Note that an actor can satisfy an asynchronous requirement with a synchronous one, in which case the normal notion of asynchronously accessing a synchronous declaration on an actor applies. For example:

ä¸€ä¸ªactorå¯ä»¥æ»¡è¶³ä¸€ä¸ªå¼‚æ­¥éœ€æ±‚ï¼Œå› ä¸ºå¯¹è¯¥éœ€æ±‚çš„ä»»ä½•ä½¿ç”¨éƒ½æ˜¯å¼‚æ­¥çš„ï¼Œå› æ­¤å¯ä»¥æš‚åœï¼Œç›´åˆ°è¯¥actorå¯ä»¥æ‰§è¡Œå®ƒä»¬ã€‚è¯·æ³¨æ„ï¼Œä¸€ä¸ªactorå¯ä»¥ç”¨ä¸€ä¸ªåŒæ­¥çš„éœ€æ±‚æ¥æ»¡è¶³ä¸€ä¸ªå¼‚æ­¥çš„éœ€æ±‚ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå¼‚æ­¥è®¿é—®ä¸€ä¸ªactorä¸Šçš„åŒæ­¥å£°æ˜çš„æ­£å¸¸æ¦‚å¿µé€‚ç”¨ã€‚æ¯”å¦‚è¯´ã€‚

```swift
protocol Server {
  func send<Message: MessageType>(message: Message) async throws -> Message.Reply
}

actor MyServer : Server {
  func send<Message: MessageType>(message: Message) throws -> Message.Reply { ... }  // okay, asynchronously accessed from clients of the protocol
}
```

### Partial applications

Partial applications of isolated functions are only permitted when the expression is a direct argument whose corresponding parameter is non-escaping and non-Sendable. For example:

åªæœ‰å½“è¡¨è¾¾å¼æ˜¯ä¸€ä¸ªç›´æ¥çš„å‚æ•°ï¼Œå…¶å¯¹åº”çš„å‚æ•°æ˜¯ä¸å¯escapingå’Œä¸å¯Sendableæ—¶ï¼Œæ‰å…è®¸å­¤ç«‹å‡½æ•°çš„éƒ¨åˆ†åº”ç”¨ã€‚ä¾‹å¦‚ã€‚

```swift
func runLater<T>(_ operation: @escaping () -> T) -> T { ... }

actor A {
  func f(_: Int) -> Double { ... }
  func g() -> Double { ... }
  
  func useAF(array: [Int]) {
    array.map(self.f)                     // okay
    detach(operation: self.g)             // error: self.g has non-sendable type () -> Double that cannot be converted to a @Sendable function type
    runLater(self.g)                      // error: self.g has escaping function type () -> Double
  }
}
```

These restrictions follow from the actor isolation rules for the "desugaring" of partial applications to closures. The two erroneous cases above fall out from the fact that the closure would be non-isolated in a closure that performs the call, so access to the actor-isolated function `g` would have to be asynchronous. Here are the "desugared" forms of the partial applications:

è¿™äº›é™åˆ¶æ¥è‡ªäºactorå¯¹é—­åŒ…çš„éƒ¨åˆ†åº”ç”¨çš„ `desugaring` çš„éš”ç¦»è§„åˆ™ã€‚ä¸Šé¢ä¸¤ä¸ªé”™è¯¯çš„ä¾‹å­æ˜¯ç”±äºåœ¨æ‰§è¡Œè°ƒç”¨çš„é—­åŒ…ä¸­ï¼Œé—­åŒ…å°†æ˜¯ééš”ç¦»çš„ï¼Œæ‰€ä»¥å¯¹è¡Œä¸ºè€…éš”ç¦»çš„å‡½æ•°`g`çš„è®¿é—®å¿…é¡»æ˜¯å¼‚æ­¥çš„ã€‚ä¸‹é¢æ˜¯éƒ¨åˆ†åº”ç”¨çš„ "å»é›•ç¢ "å½¢å¼ã€‚


```swift
extension A {
  func useAFDesugared(a: A, array: [Int]) {
    array.map { f($0) } )      // okay
    detach { g() }             // error: self is non-isolated, so call to `g` cannot be synchronous
    runLater { g() }           // error: self is non-isolated, so the call to `g` cannot be synchronous
  }
}
```

### Key paths

A key path cannot involve a reference to an actor-isolated declaration:

ä¸€ä¸ªå…³é”®è·¯å¾„ä¸èƒ½æ¶‰åŠå¯¹actor-isolatedå£°æ˜çš„å¼•ç”¨ã€‚

```swift
actor A {
  var storage: Int
}

let kp = \A.storage  // error: key path would permit access to actor-isolated storage
```

> **Rationale**: Allowing the formation of a key path that references an actor-isolated property or subscript would permit accesses to the actor's protected state from outside of the actor isolation domain. As an alternative to this rule, we could remove the `Sendable` conformance from key paths, such that one could form key paths to actor-isolated state but they could not be shared.
 
> **ç†ç”±**ã€‚å…è®¸å½¢æˆå¼•ç”¨actor isolationçš„å±æ€§æˆ–ä¸‹æ ‡çš„å…³é”®è·¯å¾„ï¼Œå°†å…è®¸ä»actor isolationåŸŸä¹‹å¤–è®¿é—®actorçš„å—ä¿æŠ¤çŠ¶æ€ã€‚ä½œä¸ºè¿™ä¸€è§„åˆ™çš„æ›¿ä»£æ–¹æ¡ˆï¼Œæˆ‘ä»¬å¯ä»¥ä»å¯†é’¥è·¯å¾„ä¸­ç§»é™¤ "å¯å‘é€ "çš„ä¸€è‡´æ€§ï¼Œè¿™æ ·äººä»¬å°±å¯ä»¥å½¢æˆæŒ‡å‘actor-isolatedçŠ¶æ€çš„å¯†é’¥è·¯å¾„ï¼Œä½†å®ƒä»¬ä¸èƒ½è¢«å…±äº«ã€‚

### inout parameters

Actor-isolated stored properties can be passed into synchronous functions via `inout` parameters, but it is ill-formed to pass them to asynchronous functions via `inout` parameters. For example:

actoréš”ç¦»çš„å­˜å‚¨å±æ€§å¯ä»¥é€šè¿‡`inout`å‚æ•°ä¼ é€’åˆ°åŒæ­¥å‡½æ•°ä¸­ï¼Œä½†é€šè¿‡`inout`å‚æ•°ä¼ é€’åˆ°å¼‚æ­¥å‡½æ•°ä¸­æ˜¯ä¸ç¬¦åˆè§„å®šçš„ã€‚æ¯”å¦‚è¯´ã€‚

```swift
func modifiesSynchronously(_: inout Double) { }
func modifiesAsynchronously(_: inout Double) async { }

extension BankAccount {
  func wildcardBalance() async {
    modifiesSynchronously(&balance)        // okay
    await modifiesAsynchronously(&balance) // error: actor-isolated property 'balance' cannot be passed 'inout' to an asynchronous function
  }
}  

class C { var state : Double }
struct Pair { var a, b : Double }
actor A {
  let someC : C
  var somePair : Pair

  func inoutModifications() async {
    modifiesSynchronously(&someC.state)        // okay
    await modifiesAsynchronously(&someC.state) // not okay
    modifiesSynchronously(&somePair.a)         // okay
    await modifiesAsynchronously(&somePair.a)  // not okay
  }
}
```

> **Rationale**: this restriction prevents exclusivity violations where the modification of the actor-isolated `balance` is initiated by passing it as `inout` to a call that is then suspended, and another task executed on the same actor then attempts to access `balance`. Such an access would then result in an exclusivity violation that will terminate the program. While the `inout` restriction is not required for memory safety (because errors will be detected at runtime), the default re-entrancy of actors makes it very easy to introduce non-deterministic exclusivity violations. Therefore, we introduce this restriction to eliminate that class of problems that where a race would trigger an exclusivity violation.

> **ç†ç”±**ï¼šè¿™ä¸ªé™åˆ¶å¯ä»¥é˜²æ­¢è¿åæ’ä»–æ€§ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå¯¹actor-isolatedçš„`å¹³è¡¡'çš„ä¿®æ”¹æ˜¯é€šè¿‡æŠŠå®ƒä½œä¸º`inout`ä¼ é€’ç»™ä¸€ä¸ªè°ƒç”¨è€Œå¼€å§‹çš„ï¼Œè¿™ä¸ªè°ƒç”¨è¢«æš‚åœï¼Œç„¶ååœ¨åŒä¸€ä¸ªactorä¸Šæ‰§è¡Œçš„å¦ä¸€ä¸ªä»»åŠ¡è¯•å›¾è®¿é—®`å¹³è¡¡`ã€‚è¿™æ ·çš„è®¿é—®å°†å¯¼è‡´æ’ä»–æ€§çš„è¿åï¼Œä»è€Œç»ˆæ­¢ç¨‹åºã€‚è™½ç„¶`inout`çš„é™åˆ¶å¯¹äºå†…å­˜å®‰å…¨æ¥è¯´æ˜¯ä¸éœ€è¦çš„ï¼ˆå› ä¸ºé”™è¯¯ä¼šåœ¨è¿è¡Œæ—¶è¢«æ£€æµ‹åˆ°ï¼‰ï¼Œä½†actorçš„é»˜è®¤é‡å…¥æ€§ä½¿å¾—å®ƒå¾ˆå®¹æ˜“å¼•å…¥éç¡®å®šæ€§çš„æ’ä»–æ€§è¿è§„ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¼•å…¥äº†è¿™ä¸ªé™åˆ¶ï¼Œä»¥æ¶ˆé™¤è¿™ç±»é—®é¢˜ï¼Œå³ç«èµ›ä¼šè§¦å‘æ’ä»–æ€§è¿åã€‚

### Actor interoperability with Objective-C

An actor type can be declared `@objc`, which implicitly provides conformance to `NSObjectProtocol`:

ä¸€ä¸ªactorç±»å‹å¯ä»¥è¢«å£°æ˜ä¸º`@objc`ï¼Œå®ƒéšå«åœ°æä¾›äº†å¯¹`NSObjectProtocol`çš„ä¸€è‡´æ€§ã€‚

```swift
@objc actor MyActor { ... }
```

A member of an actor can only be `@objc` if it is either `async` or is not isolated to the actor. Synchronous code that is within the actor's isolation domain can only be invoked on `self` (in Swift). Objective-C does not have knowledge of actor isolation, so these members are not permitted to be exposed to Objective-C. For example:

actorçš„ä¸€ä¸ªæˆå‘˜åªæœ‰åœ¨`async`æˆ–ä¸ä¸actor isolationçš„æƒ…å†µä¸‹æ‰èƒ½æˆä¸º`@objc`ã€‚åœ¨actorçš„éš”ç¦»åŸŸå†…çš„åŒæ­¥ä»£ç åªèƒ½åœ¨`self`ä¸Šè°ƒç”¨ï¼ˆåœ¨Swiftä¸­ï¼‰ã€‚Objective-Cå¹¶ä¸äº†è§£actorçš„éš”ç¦»ï¼Œæ‰€ä»¥è¿™äº›æˆå‘˜ä¸å…è®¸æš´éœ²åœ¨Objective-Cä¸­ã€‚æ¯”å¦‚è¯´ã€‚

```swift
@objc actor MyActor {
    @objc func synchronous() { } // error: part of actor's isolation domain
    @objc func asynchronous() async { } // okay: asynchronous, exposed to Objective-C as a method that accepts a completion handler
    @objc nonisolated func notIsolated() { } // okay: non-isolated
}
```

## Source compatibility

This proposal is mostly additive, and should not break source compatibility. The `actor` contextual keyword to introduce actors is a parser change that does not break existing code, and the other changes are carefully staged so they do not change existing code. Only new code that introduces actors or actor-isolation attributes will be affected.

è¿™ä¸ªå»ºè®®ä¸»è¦æ˜¯è¡¥å……æ€§çš„ï¼Œä¸åº”è¯¥ç ´åæºä»£ç çš„å…¼å®¹æ€§ã€‚å¼•å…¥æ¼”å‘˜çš„ `actor` ä¸Šä¸‹æ–‡å…³é”®å­—æ˜¯å¯¹è§£æå™¨çš„æ”¹å˜ï¼Œä¸ä¼šç ´åç°æœ‰çš„ä»£ç ï¼Œå…¶ä»–çš„æ”¹å˜ä¹Ÿæ˜¯ç²¾å¿ƒå®‰æ’çš„ï¼Œæ‰€ä»¥å®ƒä»¬ä¸ä¼šæ”¹å˜ç°æœ‰çš„ä»£ç ã€‚åªæœ‰å¼•å…¥actorsæˆ–actor-isolationå±æ€§çš„æ–°ä»£ç ä¼šå—åˆ°å½±å“ã€‚

## Effect on ABI stability

This is purely additive to the ABI. Actor isolation itself is a static notion that is not part of the ABI.

è¿™çº¯ç²¹æ˜¯å¯¹ABIçš„è¡¥å……ã€‚ä»£ç†äººéš”ç¦»æœ¬èº«æ˜¯ä¸€ä¸ªé™æ€æ¦‚å¿µï¼Œä¸æ˜¯ABIçš„ä¸€éƒ¨åˆ†ã€‚

## Effect on API resilience

Nearly all changes in actor isolation are breaking changes, because the actor isolation rules require consistency between a declaration and its users:

å‡ ä¹æ‰€æœ‰actor isolationçš„æ”¹å˜éƒ½æ˜¯ç ´åæ€§çš„æ”¹å˜ï¼Œå› ä¸ºactor isolationè§„åˆ™è¦æ±‚å£°æ˜å’Œå…¶ç”¨æˆ·ä¹‹é—´çš„ä¸€è‡´æ€§ã€‚

* A class cannot be turned into an actor or vice versa.
* The actor isolation of a public declaration cannot be changed.

* ä¸€ä¸ªç±»ä¸èƒ½å˜æˆä¸€ä¸ªactorï¼Œåä¹‹äº¦ç„¶ã€‚
* ä¸€ä¸ªå…¬å…±å£°æ˜çš„actor isolationä¸èƒ½è¢«æ”¹å˜ã€‚

## Future Directions

### Non-reentrancy

We could introduce a `@reentrant` attribute may be added to any actor-isolated function, actor, or extension of an actor to describe how it is reentrant. The attribute would have several forms:

æˆ‘ä»¬å¯ä»¥å¼•å…¥ä¸€ä¸ª"@reentrant "å±æ€§ï¼Œå®ƒå¯ä»¥è¢«æ·»åŠ åˆ°ä»»ä½•actor-isolatedçš„å‡½æ•°ã€actoræˆ–actorçš„æ‰©å±•ä¸­ï¼Œä»¥æè¿°å®ƒæ˜¯å¦‚ä½•é‡å…¥çš„ã€‚è¯¥å±æ€§å°†æœ‰å‡ ç§å½¢å¼ã€‚

* `@reentrant`: Indicates that each potential suspension point within the function bodies covered by the attribute is reentrant.
* `@reentrant(never)`: Indicates that each potential suspension point within the function bodies covered by the attribute is non-reentrant.

* `@reentrant`: è¡¨ç¤ºè¯¥å±æ€§æ‰€è¦†ç›–çš„å‡½æ•°ä½“ä¸­çš„æ¯ä¸ªæ½œåœ¨æš‚åœç‚¹æ˜¯å¯é‡å…¥çš„ã€‚
* `@reentrant(never)`: è¡¨ç¤ºè¯¥å±æ€§æ‰€æ¶µç›–çš„å‡½æ•°ä½“ä¸­çš„æ¯ä¸ªæ½œåœ¨æš‚åœç‚¹éƒ½æ˜¯ä¸å¯é€†çš„ã€‚

A non-reentrant potential suspension point prevents any other asynchronous call from executing on the actor until it has completed. Note that asynchronous calls to non-reentrant async functions directly on `self` are exempted from this check, so an actor can asynchronously call itself without producing a deadlock.

ä¸€ä¸ªéreentrantçš„æ½œåœ¨æš‚åœç‚¹ä¼šé˜»æ­¢ä»»ä½•å…¶ä»–å¼‚æ­¥è°ƒç”¨åœ¨actorä¸Šæ‰§è¡Œï¼Œç›´åˆ°å®ƒå®Œæˆã€‚è¯·æ³¨æ„ï¼Œç›´æ¥åœ¨ `self` ä¸Šå¯¹éé‡è¿›å¼‚æ­¥å‡½æ•°çš„å¼‚æ­¥è°ƒç”¨ä¸å—è¿™ä¸ªæ£€æŸ¥çš„å½±å“ï¼Œæ‰€ä»¥ä¸€ä¸ªactorå¯ä»¥å¼‚æ­¥è°ƒç”¨è‡ªå·±è€Œä¸äº§ç”Ÿæ­»é”ã€‚

> **Rationale**: Allowing direct calls on `self` eliminates an obvious set of deadlocks, and requires only the same static knowledge as actor-isolation checking for synchronous access to actor-isolated state.

> **ç†ç”±**ã€‚å…è®¸ç›´æ¥è°ƒç”¨ `self` å¯ä»¥æ¶ˆé™¤ä¸€ç³»åˆ—æ˜æ˜¾çš„æ­»é”ï¼Œå¹¶ä¸”åªéœ€è¦ä¸actor-isolatedæ£€æŸ¥ç›¸åŒçš„é™æ€çŸ¥è¯†ï¼Œå°±å¯ä»¥åŒæ­¥è®¿é—®actor isolationçš„çŠ¶æ€ã€‚

It is an error to have a `@reentrant` attribute on a non-isolated function, non-actor type, or extension of a non-actor type. Only one `@reentrant` attribute may occur on a given declaration. The reentrancy of an actor-isolated non-type declaration is determined by finding a suitable `@reentrant` attribute. The search is as follows:

åœ¨ä¸€ä¸ªéå­¤ç«‹çš„å‡½æ•°ã€éactorç±»å‹æˆ–éactorç±»å‹çš„æ‰©å±•ä¸Šæœ‰ä¸€ä¸ª`@reentrant`å±æ€§æ˜¯ä¸€ä¸ªé”™è¯¯ã€‚ä¸€ä¸ªç»™å®šçš„å£°æ˜ä¸­åªèƒ½æœ‰ä¸€ä¸ª`@reentrant`å±æ€§ã€‚ä¸€ä¸ªactoréš”ç¦»çš„éç±»å‹å£°æ˜çš„å¯é‡å…¥æ€§æ˜¯é€šè¿‡å¯»æ‰¾ä¸€ä¸ªåˆé€‚çš„`@reentrant`å±æ€§æ¥ç¡®å®šçš„ã€‚æœç´¢çš„æ–¹æ³•å¦‚ä¸‹ã€‚

1. The declaration itself.
2. If the declaration is a non-type member of an extension, the extension.
3. If the declaration is a non-type member of a type (or extension thereof), the type definition.

1. å£°æ˜æœ¬èº«ã€‚
2. å¦‚æœå£°æ˜æ˜¯ä¸€ä¸ªæ‰©å±•çš„éç±»å‹æˆå‘˜ï¼Œåˆ™æ˜¯è¯¥æ‰©å±•ã€‚
3. å¦‚æœå£°æ˜æ˜¯ä¸€ä¸ªç±»å‹ï¼ˆæˆ–å…¶æ‰©å±•ï¼‰çš„éç±»å‹æˆå‘˜ï¼Œåˆ™æ˜¯ç±»å‹å®šä¹‰ã€‚

If there is no suitable `@reentrant` attribute, an actor-isolated declaration is reentrant.

å¦‚æœæ²¡æœ‰åˆé€‚çš„"@reentrant "å±æ€§ï¼Œè¡Œä¸ºè€…éš”ç¦»çš„å£°æ˜å°±æ˜¯å¯é‡å…¥çš„ã€‚

Here's an example illustrating how the `@reentrant` attribute can be applied at various points:

ä¸‹é¢æ˜¯ä¸€ä¸ªä¾‹å­ï¼Œè¯´æ˜å¦‚ä½•åœ¨ä¸åŒç‚¹ä¸Šåº”ç”¨`@reentrant`å±æ€§ã€‚

```swift
actor Stage {
  @reentrant(never) func f() async { ... }    // not reentrant
  func g() async { ... }                      // reentrant
}

@reentrant(never)
extension Stage {
  func h() async { ... }                      // not reentrant
  @reentrant func i() async { ... }           // reentrant

  actor InnerChild {                          // reentrant, not affected by enclosing extension
    func j() async { ... }                    // reentrant
  }

  nonisolated func k() async { .. }     // okay, reentrancy is uninteresting
  nonisolated @reentrant func l() async { .. } // error: @reentrant on non-actor-isolated
}

@reentrant func m() async { ... } // error: @reentrant on non-actor-isolated
```

The attribute approach is not the only possible design here. At an implementation level, the actual blocking will be handled at each asynchronous call site. Instead of an attribute that affects potentially many asynchronous calls, we could introduce a different form of `await` that does the blocking, e.g.,

å±æ€§æ–¹æ³•ä¸æ˜¯è¿™é‡Œå”¯ä¸€å¯èƒ½çš„è®¾è®¡ã€‚åœ¨å®ç°å±‚é¢ä¸Šï¼Œå®é™…çš„é˜»å¡å°†åœ¨æ¯ä¸ªå¼‚æ­¥è°ƒç”¨ç«™ç‚¹å¤„ç†ã€‚æˆ‘ä»¬å¯ä»¥å¼•å…¥ä¸€ä¸ªä¸åŒå½¢å¼çš„`await`æ¥è¿›è¡Œé˜»å¡ï¼Œè€Œä¸æ˜¯ä¸€ä¸ªå¯èƒ½å½±å“è®¸å¤šå¼‚æ­¥è°ƒç”¨çš„å±æ€§ï¼Œä¾‹å¦‚ã€‚

```swift
await(blocking) friend.tell(opinion, heldBy: self)
```

### Task-chain reentrancy

The discussion of reentrant and non-reentrant actors treats reentrancy as a binary choice, where all forms of reentrancy are considered to be equally likely to introduce hard-to-reason-about data races. However, a frequent and usually quite understandable way of interacting between actors which are simply "conversations" between two or more actors in order fo fulfill some initial request. In synchronous code, it's common to have two or more different classes call back into each other with synchronous calls. For example, here is a silly implementation of `isEven` that uses mutual recursion between two classes:

å…³äºå¯é‡å…¥å’Œä¸å¯é‡å…¥actorçš„è®¨è®ºå°†é‡å…¥è§†ä¸ºä¸€ç§äºŒå…ƒé€‰æ‹©ï¼Œæ‰€æœ‰å½¢å¼çš„é‡å…¥éƒ½è¢«è®¤ä¸ºæ˜¯åŒæ ·å¯èƒ½å¼•å…¥éš¾ä»¥è§£é‡Šçš„æ•°æ®ç«èµ›ã€‚ç„¶è€Œï¼Œä¸€ä¸ªé¢‘ç¹çš„ã€é€šå¸¸å¾ˆå®¹æ˜“ç†è§£çš„actorä¹‹é—´çš„äº¤äº’æ–¹å¼ï¼Œå®ƒåªæ˜¯ä¸¤ä¸ªæˆ–å¤šä¸ªactorä¹‹é—´çš„ "å¯¹è¯"ï¼Œä»¥å®ç°ä¸€äº›åˆå§‹è¯·æ±‚ã€‚åœ¨åŒæ­¥ä»£ç ä¸­ï¼Œè®©ä¸¤ä¸ªæˆ–å¤šä¸ªä¸åŒçš„ç±»ä»¥åŒæ­¥è°ƒç”¨çš„æ–¹å¼ç›¸äº’å›è°ƒæ˜¯å¾ˆå¸¸è§çš„ã€‚ä¾‹å¦‚ï¼Œè¿™é‡Œæ˜¯`isEven`çš„ä¸€ä¸ªæ„šè ¢çš„å®ç°ï¼Œå®ƒåœ¨ä¸¤ä¸ªç±»ä¹‹é—´ä½¿ç”¨äº†ç›¸äº’é€’å½’ã€‚

```swift
class OddOddySync {
  let evan: EvenEvanSync!

  func isOdd(_ n: Int) -> Bool {
    if n == 0 { return true }
    return evan.isEven(num - 1)
  }
}

class EvenEvanSync {
  let oddy: OddOddySync!

  func isEven(_ n: Int) -> Bool {
    if n == 0 { return false }
    return oddy.isOdd(num - 1)
  }
}
```

This code is depending on the two methods of these classes to effectively be "reentrant" within the same call stack, because one will call into the other (and vice-versa) as part of the computation. Now, take this example and make it asynchronous using actors:

è¿™æ®µä»£ç ä¾èµ–äºè¿™äº›ç±»çš„ä¸¤ä¸ªæ–¹æ³•åœ¨åŒä¸€ä¸ªè°ƒç”¨å †æ ˆä¸­æœ‰æ•ˆåœ° "å¯é‡å…¥"ï¼Œå› ä¸ºå…¶ä¸­ä¸€ä¸ªä¼šè°ƒç”¨åˆ°å¦ä¸€ä¸ªï¼ˆåä¹‹äº¦ç„¶ï¼‰ä½œä¸ºè®¡ç®—çš„ä¸€éƒ¨åˆ†ã€‚ç°åœ¨ï¼Œä»¥è¿™ä¸ªä¾‹å­ä¸ºä¾‹ï¼Œç”¨`actor`ä½¿å…¶æˆä¸ºå¼‚æ­¥çš„ã€‚

```swift
@reentrant(never)
actor OddOddy {
  let evan: EvenEvan!

  func isOdd(_ n: Int) async -> Bool {
    if n == 0 { return true }
    return await evan.isEven(num - 1)
  }
}

@reentrant(never)
actor EvenEvan {
  let oddy: OddOddy!

  func isEven(_ n: Int) async -> Bool {
    if n == 0 { return false }
    return await oddy.isOdd(num - 1)
  }
}
```

Under `@reentrant(never)`, this code will deadlock, because a call from `EvanEvan.isEven` to `OddOddy.isOdd` will then depend on another call to `EvanEvan.isEven`, which cannot proceed until the original call completes. One would need to make these methods to be reentrant to eliminate the deadlock.

åœ¨`@reentrant(never)`ä¸‹ï¼Œè¿™æ®µä»£ç ä¼šå‡ºç°æ­»é”ï¼Œå› ä¸ºä»`EvanEvan.isEven`åˆ°`OddOddy.isOdd`çš„è°ƒç”¨å°†ä¾èµ–äºå¯¹`EvanEvan.isEven`çš„å¦ä¸€æ¬¡è°ƒç”¨ï¼Œåœ¨åŸå§‹è°ƒç”¨å®Œæˆä¹‹å‰ï¼Œæ— æ³•ç»§ç»­ã€‚æˆ‘ä»¬éœ€è¦ä½¿è¿™äº›æ–¹æ³•æˆä¸ºå¯é‡å…¥çš„ï¼Œä»¥æ¶ˆé™¤æ­»é”ã€‚

With Swift embracing [Structured Concurrency][sc] as a core building block of its concurrency story, we may be able to do better than outright banning reentrancy. In Swift, every asynchronous operation is part of a `Task` which encapsulates the general computation taking place, and every asynchronous operation spawned from such task becomes a child task of the current task. Therefore, it is possible to know whether a given asynchronous call is part of the same task hierarchy, which is the rough equivalent to being in the same call stack in synchronous code.

éšç€Swiftå°†[ç»“æ„åŒ–å¹¶å‘][sc]ä½œä¸ºå…¶å¹¶å‘æ•…äº‹çš„æ ¸å¿ƒæ„ä»¶ï¼Œæˆ‘ä»¬å¯èƒ½ä¼šæ¯”ç›´æ¥ç¦æ­¢é‡å…¥åšå¾—æ›´å¥½ã€‚åœ¨Swiftä¸­ï¼Œæ¯ä¸ªå¼‚æ­¥æ“ä½œéƒ½æ˜¯ "ä»»åŠ¡ "çš„ä¸€éƒ¨åˆ†ï¼Œ"ä»»åŠ¡ "å°è£…äº†æ­£åœ¨è¿›è¡Œçš„ä¸€èˆ¬è®¡ç®—ï¼Œä»è¿™ç§ä»»åŠ¡ä¸­äº§ç”Ÿçš„æ¯ä¸ªå¼‚æ­¥æ“ä½œéƒ½æˆä¸ºå½“å‰ä»»åŠ¡çš„ä¸€ä¸ªå­ä»»åŠ¡ã€‚å› æ­¤ï¼Œå¯ä»¥çŸ¥é“æŸä¸ªå¼‚æ­¥è°ƒç”¨æ˜¯å¦å±äºåŒä¸€ä¸ªä»»åŠ¡å±‚æ¬¡ï¼Œè¿™å¤§è‡´ç›¸å½“äºåœ¨åŒæ­¥ä»£ç ä¸­å¤„äºåŒä¸€ä¸ªè°ƒç”¨æ ˆã€‚

We could introduce a new kind of reentrancy, *task-chain reentrancy*, which allows reentrant calls on behalf of the given task or any of its children. This resolves both the deadlock we encountered in the `convinceOtherwise` example from the section on [deadlocks](#deadlocks-with-non-reentrant-actors) as well as the mutually-recursive `isEven` example above, while still preventing reentrancy from unrelated tasks. This reentrancy therefore mimics synchronous code more closely, eliminating many deadlocks without allowing unrelated interleavings to break the high-level invariants of an actor.

æˆ‘ä»¬å¯ä»¥å¼•å…¥ä¸€ç§æ–°çš„é‡å…¥ï¼Œ*ä»»åŠ¡é“¾é‡å…¥*ï¼Œå®ƒå…è®¸ä»£è¡¨ç»™å®šä»»åŠ¡æˆ–å…¶ä»»ä½•å­ä»»åŠ¡çš„é‡å…¥è°ƒç”¨ã€‚è¿™æ—¢è§£å†³äº†æˆ‘ä»¬åœ¨[deadlocks](#deadlocks-with-non-reentrant-actors)ä¸€èŠ‚ä¸­çš„`convinceOtherwise`ä¾‹å­ä¸­é‡åˆ°çš„æ­»é”ï¼Œä¹Ÿè§£å†³äº†ä¸Šé¢`isEven`ä¾‹å­ä¸­çš„ç›¸äº’é€’å½’ï¼ŒåŒæ—¶è¿˜èƒ½é˜²æ­¢ä¸ç›¸å…³ä»»åŠ¡çš„å†å…¥ã€‚å› æ­¤ï¼Œè¿™ç§é‡å…¥æ›´æ¥è¿‘äºæ¨¡ä»¿åŒæ­¥ä»£ç ï¼Œæ¶ˆé™¤äº†è®¸å¤šæ­»é”ï¼Œè€Œä¸å…è®¸ä¸ç›¸å…³çš„äº¤ç»‡ç ´åactorçš„é«˜å±‚ä¸å˜æ€§ã€‚

There are a few reasons why we are not currently comfortale including task-chain reentrancy in the proposal:

æœ‰å‡ ä¸ªåŸå› å¯ä»¥è¯´æ˜æˆ‘ä»¬ç›®å‰æ²¡æœ‰æŠŠä»»åŠ¡é“¾é‡å…¥æ€§çº³å…¥ææ¡ˆä¸­çš„å®‰æ…°ã€‚

* The task-based reentrancy approach doesn't seem to have been tried at scale. Orleans documents support for [reentrancy in a call chain](https://dotnet.github.io/orleans/docs/grains/reentrancy.html#reentrancy-within-a-call-chain), but the implementation was fairly limited and it was eventually [removed](https://twitter.com/reubenbond/status/1349725703634251779). From the Orleans experience, it is hard to assess whether the problem is with the idea or the specific implementation.
* We do not yet know of an efficient implementation technique for this approach within the actor runtime.

* åŸºäºä»»åŠ¡çš„é‡å…¥æ–¹æ³•ä¼¼ä¹è¿˜æ²¡æœ‰è¢«å¤§è§„æ¨¡åœ°å°è¯•è¿‡ã€‚Orleansè®°å½•äº†å¯¹[è°ƒç”¨é“¾ä¸­çš„é‡å…¥]çš„æ”¯æŒ(https://dotnet.github.io/orleans/docs/grains/reentrancy.html#reentrancy-within-a-call-chain)ï¼Œä½†å®æ–½ç›¸å½“æœ‰é™ï¼Œæœ€ç»ˆè¢«[åˆ é™¤](https://twitter.com/reubenbond/status/1349725703634251779)ã€‚ä»Orleansçš„ç»éªŒæ¥çœ‹ï¼Œå¾ˆéš¾è¯„ä¼°é—®é¢˜æ˜¯å‡ºåœ¨æƒ³æ³•ä¸Šè¿˜æ˜¯å…·ä½“çš„å®ç°ä¸Šã€‚
* æˆ‘ä»¬è¿˜ä¸çŸ¥é“è¿™ç§æ–¹æ³•åœ¨actorè¿è¡Œæ—¶ä¸­çš„æœ‰æ•ˆå®ç°æŠ€æœ¯ã€‚

If we can address the above, task-chain reentrancy can be introduced into the actor model with another spelling of the reentrancy attribute such as `@reentrant(task)`, and may provide the best default.

å¦‚æœæˆ‘ä»¬èƒ½å¤Ÿè§£å†³ä¸Šè¿°é—®é¢˜ï¼Œä»»åŠ¡é“¾é‡å…¥å¯ä»¥é€šè¿‡é‡å…¥å±æ€§çš„å¦ä¸€ç§æ‹¼æ³•ï¼Œå¦‚`@reentrant(task)`ï¼Œå¼•å…¥åˆ°actoræ¨¡å‹ä¸­ï¼Œå¹¶å¯èƒ½æä¾›æœ€ä½³çš„é»˜è®¤å€¼ã€‚

## Alternatives considered

### Actor inheritance

Earlier pitches and the first reviewed version of this proposal allowed actor inheritance. Actor inheritance followed the rules of class inheritance, albeit with specific additional rules required to maintain actor isolation:

æ—©æœŸçš„ææ¡ˆå’Œæœ¬ææ¡ˆçš„ç¬¬ä¸€ä¸ªå®¡æŸ¥ç‰ˆæœ¬å…è®¸actorç»§æ‰¿ã€‚actorçš„ç»§æ‰¿éµå¾ªç±»çš„ç»§æ‰¿è§„åˆ™ï¼Œå°½ç®¡æœ‰ç‰¹å®šçš„é¢å¤–è§„åˆ™æ¥ç»´æŒactorçš„éš”ç¦»ã€‚

* An actor could not inherit from a class, and vice-versa.
* An overriding declaration must not be more isolated than the overridden declaration.

* ä¸€ä¸ªactorä¸èƒ½ç»§æ‰¿äºä¸€ä¸ªç±»ï¼Œåä¹‹äº¦ç„¶ã€‚
* ä¸€ä¸ªè¦†ç›–çš„å£°æ˜ä¸èƒ½æ¯”è¢«è¦†ç›–çš„å£°æ˜æ›´å­¤ç«‹ã€‚

Subsequent review discussion determined that the conceptual cost of actor inheritance outweighed its usefulness, so it has been removed from this proposal. The form that actor inheritance would take in the language is well-understand from prior iterations of this proposal and its implementation, so this feature could be re-introduced at a later time.

éšåçš„å®¡æŸ¥è®¨è®ºç¡®å®šï¼Œactorç»§æ‰¿çš„æ¦‚å¿µæˆæœ¬è¶…è¿‡äº†å®ƒçš„å®ç”¨æ€§ï¼Œæ‰€ä»¥å®ƒå·²ç»ä»è¿™ä¸ªææ¡ˆä¸­åˆ é™¤ã€‚actorç»§æ‰¿åœ¨è¯­è¨€ä¸­é‡‡å–çš„å½¢å¼ï¼Œåœ¨æœ¬ææ¡ˆçš„å…ˆå‰è¿­ä»£å’Œå®æ–½ä¸­å·²è¢«å……åˆ†ç†è§£ï¼Œæ‰€ä»¥è¿™ä¸€ç‰¹æ€§å¯ä»¥åœ¨ä»¥åé‡æ–°å¼•å…¥ã€‚

### Cross-actor lets

This proposal requires cross-actor access to `let` properties to be asynchronous, which is consistent with `var` properties. Because `let` properties are immutable, accessing from outside of the actor's concurrency domain is safe, so `let` properties could implicitly be non-isolated. This would allow code such as the following:

è¿™ä¸ªå»ºè®®è¦æ±‚å¯¹`let`å±æ€§çš„è·¨actorè®¿é—®æ˜¯å¼‚æ­¥çš„ï¼Œè¿™ä¸`var`å±æ€§ä¸€è‡´ã€‚å› ä¸º `let` å±æ€§æ˜¯ä¸mutableçš„ï¼Œä»actorçš„å¹¶å‘åŸŸä¹‹å¤–è®¿é—®æ˜¯å®‰å…¨çš„ï¼Œæ‰€ä»¥ `let` å±æ€§å¯ä»¥éšå«åœ°è¢«ééš”ç¦»ã€‚è¿™å°†å…è®¸ä»¥ä¸‹çš„ä»£ç ã€‚

```swift
actor BankAccount {
  let accountNumber: Int
}

func print(account: BankAccount) {
  print(account.accountNumber) // okay with this change: synchronous access to an actor's let property is safe
}  
```

There are some down sides to such a change. For example, it would prevent one from evolving a `let` into a `var` without breaking clients, e.g., 

è¿™æ ·çš„æ”¹å˜æœ‰ä¸€äº›ä¸åˆ©å› ç´ ã€‚ä¾‹å¦‚ï¼Œå®ƒå°†é˜»æ­¢äººä»¬åœ¨ä¸ç ´åå®¢æˆ·ç«¯çš„æƒ…å†µä¸‹å°† `let` æ¼”å˜ä¸º "var"ï¼Œä¾‹å¦‚ã€‚

```swift
actor BankAccount {
  private(set) var accountNumber: Int  // changing 'let' to 'var' breaks clients synchronously accessing data
}
```

The actors proposal by itself does not provide any means for synchronous access to `let` properties (or anything else within an actor). The proposal on [controlling actor isolation][isolationcontrol] allows one to mark `let` declarations as `nonisolated`:

actorææ¡ˆæœ¬èº«å¹¶æ²¡æœ‰ä¸ºåŒæ­¥è®¿é—® `let` å±æ€§ï¼ˆæˆ–actorä¸­çš„å…¶ä»–ä¸œè¥¿ï¼‰æä¾›ä»»ä½•æ–¹æ³•ã€‚å…³äº[æ§åˆ¶actoréš”ç¦»][isolationcontrol]çš„æè®®å…è®¸äººä»¬å°† `let` å£°æ˜æ ‡è®°ä¸º "ééš”ç¦»"ã€‚

```swift
actor BankAccount {
  nonisolated let accountNumber: Int
}

func print(account: BankAccount) {
  print(account.accountNumber) // okay: synchronous access to an actor's let property marked as 'nonisolated'
}  
```

## Revision history

* Changes in the final accepted version of the proposal:
  * Cross-actor references to instance `let` properties must be asynchronous.
* Changes in the second reviewed proposal:
  * Escaping closures can now be actor-isolated; only `@Sendable` prevents isolation.
  * Removed actor inheritance. It can be considered at some future point.
  * Added "cross-actor lets" to Alternatives Considered. While there is no change to the proposed direction, the issue is explained here for further discussion.
  * Replaced `Task.runDetached` with `detach` to match updates to the [Structured Concurrency proposal][sc].
* Changes in the seventh pitch:
  * Removed isolated parameters and `nonisolated` from this proposal. They'll come in a follow-up proposal on [controlling actor isolation][isolationcontrol].
* Changes in the sixth pitch:
  * Make the instance requirements of `Actor` protocols actor-isolated to `self`, and allow actor types to conform to such protocols using actor-isolated witnesses.
  * Reflow the "Proposed Solution" section to get the bigger ideas out earlier.
  * Remove `nonisolated(unsafe)`.
* Changes in the fifth pitch:
  * Drop the prohibition on having multiple `isolated` parameters. We don't need to ban it.
  * Add the `Actor` protocol back, as an empty protocol whose details will be filled in with a subsequent proposal for [custom executors][customexecs].
  * Replace `ConcurrentValue` with `Sendable` and `@concurrent` with `@Sendable` to track the evolution of [SE-0302][se302].
  * Clarify the presentation of actor isolation checking.
  * Add more examples for non-isolated declarations.
  * Added a section on isolated or "sync" actor types.
* Changes in the fourth pitch:
  * Allow cross-actor references to actor properties, so long as they are reads (not writes or `inout` references)
  * Added `isolated` parameters, to generalize the previously-special behavior of `self` in an actor and make the semantics of `nonisolated` more clear.
  * Limit `nonisolated(unsafe)` to stored instance properties. The prior definition was far too broad.
  * Clarify that `super` is isolated if `self` is.
  * Prohibit references to actor-isolated declarations in key paths.
  * Clarify the behavior of partial applications.
  * Added a "future directions" section describing isolated protocol conformances.
* Changes in the third pitch:
  * Narrow the proposal down to only support re-entrant actors. Capture several potential non-reentrant designs in the Alternatives Considered as possible future extensions.
  * Replaced `@actorIndependent` attribute with a `nonisolated` modifier, which follows the approach of `nonmutating` and ties in better with the "actor isolation" terminology (thank you to Xiaodi Wu for the suggestion).
  * Replaced "queue" terminology with the more traditional "mailbox" terminology, to try to help alleviate confusion with Dispatch queues.
  * Introduced "cross-actor reference" terminology and the requirement that cross-actor references always traffic in `Sendable` types.
  * Reference `@concurrent` function types from their separate proposal.
  * Moved Objective-C interoperability into its own section.
  * Clarify the "class-like" behaviors of actor types, such as satisfying an `AnyObject` conformance.
* Changes in the second pitch:
  * Added a discussion of the tradeoffs with actor reentrancy, performance, and deadlocks, with various examples, and the addition of new attribute `@reentrant(never)` to disable reentrancy at the actor or function level.
  * Removed global actors; they will be part of a separate document.
  * Separated out the discussion of data races for reference types.
  * Allow asynchronous calls to synchronous actor methods from outside the actor.
  * Removed the `Actor` protocol; we'll tackle customizing actors and executors in a separate proposal.
  * Clarify the role and behavior of actor-independence.
  * Add a section to "Alternatives Considered" that discusses actor inheritance.
  * Replace "actor class" with "actor".
* Original pitch [document](https://github.com/DougGregor/swift-evolution/blob/6fd3903ed348b44496b32a39b40f6b6a538c83ce/proposals/nnnn-actors.md)


[sc]: https://github.com/apple/swift-evolution/blob/main/proposals/0304-structured-concurrency.md
[se302]: https://github.com/apple/swift-evolution/blob/main/proposals/0302-concurrent-value-and-concurrent-closures.md
[customexecs]: https://github.com/rjmccall/swift-evolution/blob/custom-executors/proposals/0000-custom-executors.md
[isolationcontrol]: https://github.com/DougGregor/swift-evolution/blob/actor-isolation-control/proposals/nnnn-actor-isolation-control.md